From cb3f554658b6c979bf9649509d8c7a6cd3b8a9a4 Mon Sep 17 00:00:00 2001
From: Josh Blum <josh@joshknows.com>
Date: Thu, 11 Apr 2013 15:40:25 -0700
Subject: [PATCH 4/5] uhd: fixes for time_spec's to_ticks and from_ticks calls

The fixes address rouding issues when the tick_rate is a non-integer.

Conflicts:

	host/tests/time_spec_test.cpp
---
 host/lib/types/time_spec.cpp  |   14 ++++++++------
 host/tests/time_spec_test.cpp |   29 +++++++++++++++++++++++++++++
 2 files changed, 37 insertions(+), 6 deletions(-)

diff --git a/host/lib/types/time_spec.cpp b/host/lib/types/time_spec.cpp
index ec939e5..2fce841 100644
--- a/host/lib/types/time_spec.cpp
+++ b/host/lib/types/time_spec.cpp
@@ -1,5 +1,5 @@
 //
-// Copyright 2011-2012 Ettus Research LLC
+// Copyright 2011-2013 Ettus Research LLC
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -16,7 +16,6 @@
 //
 
 #include <uhd/types/time_spec.hpp>
-#include <inttypes.h> //imaxdiv, intmax_t
 
 using namespace uhd;
 
@@ -101,8 +100,9 @@ time_spec_t::time_spec_t(time_t full_secs, long tick_count, double tick_rate){
 }
 
 time_spec_t time_spec_t::from_ticks(long long ticks, double tick_rate){
-    const imaxdiv_t divres = imaxdiv(ticks, fast_llround(tick_rate));
-    return time_spec_t(time_t(divres.quot), double(divres.rem)/tick_rate);
+    const time_t secs_full = time_t(ticks/tick_rate);
+    const double ticks_error = ticks - (secs_full*tick_rate);
+    return time_spec_t(secs_full, ticks_error/tick_rate);
 }
 
 /***********************************************************************
@@ -113,8 +113,10 @@ long time_spec_t::get_tick_count(double tick_rate) const{
 }
 
 long long time_spec_t::to_ticks(double tick_rate) const{
-    return fast_llround(this->get_frac_secs()*tick_rate) + \
-    (this->get_full_secs() * fast_llround(tick_rate));
+    const long long ticks_full = this->get_full_secs()*fast_llround(tick_rate);
+    const double secs_error = this->get_full_secs() - (ticks_full/tick_rate);
+    const double secs_frac = this->get_frac_secs() + secs_error;
+    return ticks_full + fast_llround(secs_frac*tick_rate);
 }
 
 double time_spec_t::get_real_secs(void) const{
diff --git a/host/tests/time_spec_test.cpp b/host/tests/time_spec_test.cpp
index 102b7cd..7dee95c 100644
--- a/host/tests/time_spec_test.cpp
+++ b/host/tests/time_spec_test.cpp
@@ -97,3 +97,32 @@ BOOST_AUTO_TEST_CASE(test_time_spec_neg_values){
     BOOST_CHECK(tsa > tsb);
     BOOST_CHECK(tsc > tsd);
 }
+
+BOOST_AUTO_TEST_CASE(test_time_large_ticks_to_time_spec)
+{
+    std::cout << "sizeof(time_t) " << sizeof(time_t) << std::endl;
+    const boost::uint64_t ticks0 = boost::uint64_t(100e6*1360217663.739296);
+    const uhd::time_spec_t t0 = uhd::time_spec_t::from_ticks(ticks0, 100e6);
+    std::cout << "t0.get_real_secs() " << t0.get_real_secs() << std::endl;
+    std::cout << "t0.get_full_secs() " << t0.get_full_secs() << std::endl;
+    std::cout << "t0.get_frac_secs() " << t0.get_frac_secs() << std::endl;
+    BOOST_CHECK_EQUAL(t0.get_full_secs(), time_t(1360217663));
+}
+
+BOOST_AUTO_TEST_CASE(test_time_error_irrational_rate)
+{
+    static const double rate = 1625e3/6;
+    const long long tick_in = 23423436291667;
+    const uhd::time_spec_t ts = uhd::time_spec_t::from_ticks(tick_in, rate);
+    const long long tick_out = ts.to_ticks(rate);
+    const long long err = tick_in - tick_out;
+
+    std::cout << std::setprecision(18);
+    std::cout << "time ............ " << ts.get_real_secs() << std::endl;
+    std::cout << "tick in ......... " << tick_in << std::endl;
+    std::cout << "tick out ........ " << tick_out << std::endl;
+    std::cout << "tick error ...... " << err << std::endl;
+    std::cout << std::endl;
+
+    BOOST_CHECK_EQUAL(err, (long long)(0));
+}
-- 
1.7.10.4

