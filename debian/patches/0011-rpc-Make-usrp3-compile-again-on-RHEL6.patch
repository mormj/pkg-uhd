From 573d39c8b33b2f16ba6bd8d007423e5df315ad02 Mon Sep 17 00:00:00 2001
From: Moritz <moritz@ettus.com>
Date: Mon, 23 Dec 2013 10:40:54 +0100
Subject: [PATCH 11/39] rpc: Make usrp3 compile again on RHEL6.

* boost::asio::connect appears in boost 1.47
  added conditional for older machines

* boost::system::get_system_category() instead of
  boost::system::system_category.

Signed-off-by: Moritz <moritz@ettus.com>
---
 host/lib/transport/nirio/rpc/rpc_client.cpp |   36 ++++++++++++++++++++-------
 1 file changed, 27 insertions(+), 9 deletions(-)

diff --git a/host/lib/transport/nirio/rpc/rpc_client.cpp b/host/lib/transport/nirio/rpc/rpc_client.cpp
index a5f8cf4..c16a844 100644
--- a/host/lib/transport/nirio/rpc/rpc_client.cpp
+++ b/host/lib/transport/nirio/rpc/rpc_client.cpp
@@ -17,7 +17,9 @@
 
 #include <uhd/transport/nirio/rpc/rpc_client.hpp>
 #include <boost/bind.hpp>
+#include <boost/version.hpp>
 #include <boost/format.hpp>
+#include <boost/asio/error.hpp>
 
 #define CHAIN_BLOCKING_XFER(func, exp, status) \
     if (status) { \
@@ -48,7 +50,23 @@ rpc_client::rpc_client (
         tcp::resolver resolver(_io_service);
         tcp::resolver::query query(tcp::v4(), server, port);
         tcp::resolver::iterator iterator = resolver.resolve(query);
-        boost::asio::connect(_socket, iterator);
+
+        #if BOOST_VERSION < 104700
+            // default constructor creates end iterator
+            tcp::resolver::iterator end;
+
+            boost::system::error_code error = boost::asio::error::host_not_found;
+            while (error && iterator != end)
+            {
+                _socket.close();
+                _socket.connect(*iterator++, error);
+            }
+            if (error)
+                throw boost::system::system_error(error);
+        #else
+            boost::asio::connect(_socket, iterator);
+        #endif
+
         UHD_LOG << "rpc_client connected to server." << std::endl;
 
         try {
@@ -74,18 +92,18 @@ rpc_client::rpc_client (
                 _io_service_thread.reset(new boost::thread(boost::bind(&boost::asio::io_service::run, &_io_service)));
             } else {
                 UHD_LOG << "rpc_client handshake failed." << std::endl;
-                _exec_err.assign(boost::asio::error::connection_refused, boost::system::system_category());
+                _exec_err.assign(boost::asio::error::connection_refused, boost::asio::error::get_system_category());
             }
             UHD_LOG << boost::format("rpc_client archive = %d, rpc_server archive = %d\n.") %
                 _hshake_args_client.boost_archive_version %
                 _hshake_args_server.boost_archive_version;
         } catch (boost::exception&) {
             UHD_LOG << "rpc_client handshake aborted." << std::endl;
-            _exec_err.assign(boost::asio::error::connection_refused, boost::system::system_category());
+            _exec_err.assign(boost::asio::error::connection_refused, boost::asio::error::get_system_category());
         }
     } catch (boost::exception&) {
         UHD_LOG << "rpc_client connection request cancelled/aborted." << std::endl;
-        _exec_err.assign(boost::asio::error::connection_aborted, boost::system::system_category());
+        _exec_err.assign(boost::asio::error::connection_aborted, boost::asio::error::get_system_category());
     }
 }
 
@@ -126,18 +144,18 @@ const boost::system::error_code& rpc_client::call(
         if (status) {
             if (!_exec_gate.timed_wait(lock, timeout)) {
                 UHD_LOG << "rpc_client function timed out." << std::endl;
-                _exec_err.assign(boost::asio::error::timed_out, boost::system::system_category());
+                _exec_err.assign(boost::asio::error::timed_out, boost::asio::error::get_system_category());
             }
         } else {
             UHD_LOG << "rpc_client connection dropped." << std::endl;
-            _exec_err.assign(boost::asio::error::connection_aborted, boost::system::system_category());
+            _exec_err.assign(boost::asio::error::connection_aborted, boost::asio::error::get_system_category());
             _stop_io_service();
         }
 
         //Verify that we are talking to the correct endpoint
         if ((_request.header.client_id != _response.header.client_id) && !_exec_err) {
             UHD_LOG << "rpc_client confused about who its talking to." << std::endl;
-            _exec_err.assign(boost::asio::error::operation_aborted, boost::system::system_category());
+            _exec_err.assign(boost::asio::error::operation_aborted, boost::asio::error::get_system_category());
         }
 
         if (!_exec_err) out_args.load(_response.data);
@@ -165,7 +183,7 @@ void rpc_client::_handle_response_hdr(const boost::system::error_code& err, size
         } else {
             //Unexpected response. Ignore it.
             UHD_LOG << "rpc_client received garbage responses." << std::endl;
-            _exec_err.assign(boost::asio::error::operation_aborted, boost::system::system_category());
+            _exec_err.assign(boost::asio::error::operation_aborted, boost::asio::error::get_system_category());
 
             _wait_for_next_response_header();
         }
@@ -179,7 +197,7 @@ void rpc_client::_handle_response_data(const boost::system::error_code& err, siz
     boost::mutex::scoped_lock lock(_mutex);
     _exec_err = err;
     if (transferred != expected) {
-        _exec_err.assign(boost::asio::error::operation_aborted, boost::system::system_category());
+        _exec_err.assign(boost::asio::error::operation_aborted, boost::asio::error::get_system_category());
     }
 
     _exec_gate.notify_all();
-- 
1.7.10.4

