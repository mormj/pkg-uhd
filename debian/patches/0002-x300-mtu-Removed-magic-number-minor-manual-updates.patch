From 00da85f96a4c51fbf4c7b65a95d2a75c17a3278d Mon Sep 17 00:00:00 2001
From: Martin Braun <martin.braun@ettus.com>
Date: Thu, 13 Feb 2014 18:00:50 -0800
Subject: [PATCH 02/39] x300 mtu: Removed magic number, minor manual updates

---
 host/docs/usrp_x3x0_config.rst   |    7 ++++---
 host/lib/usrp/x300/x300_impl.cpp |   25 ++++++++++++-------------
 host/lib/usrp/x300/x300_impl.hpp |    2 +-
 3 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/host/docs/usrp_x3x0_config.rst b/host/docs/usrp_x3x0_config.rst
index 9cb0002..22ef8c5 100644
--- a/host/docs/usrp_x3x0_config.rst
+++ b/host/docs/usrp_x3x0_config.rst
@@ -69,19 +69,20 @@ Configuring the MTU
 -------------------------------------
 In order to achieve maximum performance, we recommend setting the MTU size to
 9000 for 10 GigE and 1500 for 1 GigE. It is possible to use smaller MTUs, but this
-can affect performance. With some NICs, setting the MTU too high can also cause issues,
-though. To set the MTU to 9000, you can use the following command:
+can affect performance. With some NICs, setting the MTU too high can also cause issues.
+To set the MTU to 9000, you can use the following command:
 
 ::
 
     sudo ifconfig <interface> mtu 9000 # For 10 GigE
+    sudo ifconfig <interface> mtu 1500 # For 1 GigE
 
 Using these MTUs will set the frame sizes for UHD communication to 8000 and 1472,
 respectively.
 
 In some cases, specifying the frame size manually by adding the argument
 "<send/recv>_frame_size=1472" can solve issues. Note that a frame size of 1472 will limit
-the available sampling rate, although this is likely not a problem issue on 1 GigE.
+the available sampling rate, although this is not a problem on 1 GigE.
 
 
 Configuring the Firewall
diff --git a/host/lib/usrp/x300/x300_impl.cpp b/host/lib/usrp/x300/x300_impl.cpp
index b20897f..298844d 100644
--- a/host/lib/usrp/x300/x300_impl.cpp
+++ b/host/lib/usrp/x300/x300_impl.cpp
@@ -430,16 +430,16 @@ void x300_impl::setup_mb(const size_t mb_i, const uhd::device_addr_t &dev_addr)
 
         // Detect the frame size on the path to the USRP
         try {
-            max_frame_sizes = determine_max_frame_size(mb.addr, req_max_frame_size);
+            _max_frame_sizes = determine_max_frame_size(mb.addr, req_max_frame_size);
         } catch(std::exception &e) {
             UHD_MSG(error) << e.what() << std::endl;
         }
 
         if ((mb.recv_args.has_key("recv_frame_size"))
-                && (req_max_frame_size.recv_frame_size < max_frame_sizes.recv_frame_size)) {
+                && (req_max_frame_size.recv_frame_size < _max_frame_sizes.recv_frame_size)) {
             UHD_MSG(warning)
                 << boost::format("You requested a receive frame size of (%lu) but your NIC's max frame size is (%lu).")
-                % req_max_frame_size.recv_frame_size << max_frame_sizes.recv_frame_size << std::endl
+                % req_max_frame_size.recv_frame_size << _max_frame_sizes.recv_frame_size << std::endl
                 << boost::format("Please verify your NIC's MTU setting using '%s' or set the recv_frame_size argument appropriately.")
                 % mtu_tool << std::endl
                 << "UHD will use the auto-detected max frame size for this connection."
@@ -447,10 +447,10 @@ void x300_impl::setup_mb(const size_t mb_i, const uhd::device_addr_t &dev_addr)
         }
 
         if ((mb.recv_args.has_key("send_frame_size"))
-                && (req_max_frame_size.send_frame_size < max_frame_sizes.send_frame_size)) {
+                && (req_max_frame_size.send_frame_size < _max_frame_sizes.send_frame_size)) {
             UHD_MSG(warning)
                 << boost::format("You requested a send frame size of (%lu) but your NIC's max frame size is (%lu).")
-                % req_max_frame_size.send_frame_size << max_frame_sizes.send_frame_size << std::endl
+                % req_max_frame_size.send_frame_size << _max_frame_sizes.send_frame_size << std::endl
                 << boost::format("Please verify your NIC's MTU setting using '%s' or set the send_frame_size argument appropriately.")
                 % mtu_tool << std::endl
                 << "UHD will use the auto-detected max frame size for this connection."
@@ -1120,29 +1120,28 @@ x300_impl::both_xports_t x300_impl::make_transport(
 
         /* Print a warning if the system's max available frame size is less than the most optimal
          * frame size for this type of connection. */
-        if (max_frame_sizes.send_frame_size < eth_data_rec_frame_size) {
+        if (_max_frame_sizes.send_frame_size < eth_data_rec_frame_size) {
             UHD_MSG(warning)
                 << boost::format("For this connection, UHD recommends a send frame size of at least %lu for best\nperformance, but your system's MTU will only allow %lu.")
                 % eth_data_rec_frame_size
-                % max_frame_sizes.send_frame_size
+                % _max_frame_sizes.send_frame_size
                 << std::endl
                 << "This will negatively impact your maximum achievable sample rate."
                 << std::endl;
         }
 
-        if (max_frame_sizes.recv_frame_size < eth_data_rec_frame_size) {
+        if (_max_frame_sizes.recv_frame_size < eth_data_rec_frame_size) {
             UHD_MSG(warning)
                 << boost::format("For this connection, UHD recommends a receive frame size of at least %lu for best\nperformance, but your system's MTU will only allow %lu.")
                 % eth_data_rec_frame_size
-                % max_frame_sizes.recv_frame_size
+                % _max_frame_sizes.recv_frame_size
                 << std::endl
                 << "This will negatively impact your maximum achievable sample rate."
                 << std::endl;
         }
 
-	// Account for headers
-        size_t system_max_send_frame_size = (size_t) max_frame_sizes.send_frame_size - 64;
-        size_t system_max_recv_frame_size = (size_t) max_frame_sizes.recv_frame_size - 64;
+	size_t system_max_send_frame_size = (size_t) _max_frame_sizes.send_frame_size;
+	size_t system_max_recv_frame_size = (size_t) _max_frame_sizes.recv_frame_size;
 
 	// Make sure frame sizes do not exceed the max available value supported by UHD
         default_buff_args.send_frame_size =
@@ -1165,7 +1164,7 @@ x300_impl::both_xports_t x300_impl::make_transport(
             ? X300_ETH_DATA_NUM_FRAMES
             : X300_ETH_MSG_NUM_FRAMES;
 
-        //make a new transport - fpga has no idea how to talk to use on this yet
+        //make a new transport - fpga has no idea how to talk to us on this yet
         udp_zero_copy::buff_params buff_params;
         xports.recv = udp_zero_copy::make(mb.addr,
                 BOOST_STRINGIZE(X300_VITA_UDP_PORT),
diff --git a/host/lib/usrp/x300/x300_impl.hpp b/host/lib/usrp/x300/x300_impl.hpp
index 1fb3676..264fc10 100644
--- a/host/lib/usrp/x300/x300_impl.hpp
+++ b/host/lib/usrp/x300/x300_impl.hpp
@@ -253,7 +253,7 @@ private:
         size_t recv_frame_size;
         size_t send_frame_size;
     };
-    frame_size_t max_frame_sizes;
+    frame_size_t _max_frame_sizes;
 
     /*!
      * Automatically determine the maximum frame size available by sending a UDP packet
-- 
1.7.10.4

