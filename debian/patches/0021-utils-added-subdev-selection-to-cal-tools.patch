From 59bfb27a13863acbe94dc10272b7d54ca2471f4f Mon Sep 17 00:00:00 2001
From: Martin Braun <martin.braun@ettus.com>
Date: Fri, 21 Feb 2014 18:42:07 +0100
Subject: [PATCH 21/39] utils: added subdev selection to cal tools

---
 host/utils/uhd_cal_rx_iq_balance.cpp |   18 +++++++++++++++---
 host/utils/uhd_cal_tx_dc_offset.cpp  |   16 ++++++++++++++--
 host/utils/uhd_cal_tx_iq_balance.cpp |   19 ++++++++++++++++---
 host/utils/usrp_cal_utils.hpp        |   31 +++++++++++++++++++++----------
 4 files changed, 66 insertions(+), 18 deletions(-)

diff --git a/host/utils/uhd_cal_rx_iq_balance.cpp b/host/utils/uhd_cal_rx_iq_balance.cpp
index 5fb4941..551da75 100644
--- a/host/utils/uhd_cal_rx_iq_balance.cpp
+++ b/host/utils/uhd_cal_rx_iq_balance.cpp
@@ -20,6 +20,7 @@
 #include <uhd/utils/safe_main.hpp>
 #include <uhd/utils/paths.hpp>
 #include <uhd/utils/algorithm.hpp>
+#include <uhd/utils/msg.hpp>
 #include <uhd/usrp/multi_usrp.hpp>
 #include <boost/program_options.hpp>
 #include <boost/format.hpp>
@@ -93,7 +94,7 @@ static double tune_rx_and_tx(uhd::usrp::multi_usrp::sptr usrp, const double rx_l
  * Main
  **********************************************************************/
 int UHD_SAFE_MAIN(int argc, char *argv[]){
-    std::string args;
+    std::string args, subdev, serial;
     double tx_wave_ampl, tx_offset;
     double freq_start, freq_stop, freq_step;
     size_t nsamps;
@@ -102,7 +103,8 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     desc.add_options()
         ("help", "help message")
         ("verbose", "enable some verbose")
-        ("args", po::value<std::string>(&args)->default_value(""), "device address args [default = \"\"]")
+        ("args", po::value<std::string>(&args)->default_value(""), "Device address args [default = \"\"]")
+        ("subdev", po::value<std::string>(&subdev), "Subdevice specification (default: first subdevice, often 'A')")
         ("tx_wave_ampl", po::value<double>(&tx_wave_ampl)->default_value(0.7), "Transmit wave amplitude in counts")
         ("tx_offset", po::value<double>(&tx_offset)->default_value(.9344e6), "TX LO offset from the RX LO in Hz")
         ("freq_start", po::value<double>(&freq_start), "Frequency start in Hz (do not specify for default)")
@@ -129,6 +131,15 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     std::cout << boost::format("Creating the usrp device with: %s...") % args << std::endl;
     uhd::usrp::multi_usrp::sptr usrp = uhd::usrp::multi_usrp::make(args);
 
+    // Configure subdev
+    if (vm.count("subdev")) {
+        usrp->set_tx_subdev_spec(subdev);
+        usrp->set_rx_subdev_spec(subdev);
+    }
+    UHD_MSG(status) << "Running calibration for " << usrp->get_tx_subdev_name(0) << std::endl;
+    serial = get_serial(usrp, "tx");
+    UHD_MSG(status) << "Daughterboard serial: " << serial << std::endl;
+
     //set the antennas to cal
     if (not uhd::has(usrp->get_rx_antennas(), "CAL") or not uhd::has(usrp->get_tx_antennas(), "CAL")){
         throw std::runtime_error("This board does not have the CAL antenna option, cannot self-calibrate.");
@@ -158,6 +169,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
 
     if (not vm.count("freq_start")) freq_start = usrp->get_rx_freq_range().start() + 50e6;
     if (not vm.count("freq_stop")) freq_stop = usrp->get_rx_freq_range().stop() - 50e6;
+    UHD_MSG(status) << boost::format("Calibration frequency range: %d MHz -> %d MHz") % (freq_start/1e6) % (freq_stop/1e6) << std::endl;
 
     for (double rx_lo_i = freq_start; rx_lo_i <= freq_stop; rx_lo_i += freq_step){
         const double rx_lo = tune_rx_and_tx(usrp, rx_lo_i, tx_offset);
@@ -238,7 +250,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     threads.interrupt_all();
     threads.join_all();
 
-    store_results(usrp, results, "RX", "rx", "iq");
+    store_results(results, "RX", "rx", "iq", serial);
 
     return EXIT_SUCCESS;
 }
diff --git a/host/utils/uhd_cal_tx_dc_offset.cpp b/host/utils/uhd_cal_tx_dc_offset.cpp
index c9cf757..eb82db8 100644
--- a/host/utils/uhd_cal_tx_dc_offset.cpp
+++ b/host/utils/uhd_cal_tx_dc_offset.cpp
@@ -20,6 +20,7 @@
 #include <uhd/utils/safe_main.hpp>
 #include <uhd/utils/paths.hpp>
 #include <uhd/utils/algorithm.hpp>
+#include <uhd/utils/msg.hpp>
 #include <uhd/usrp/multi_usrp.hpp>
 #include <boost/program_options.hpp>
 #include <boost/format.hpp>
@@ -94,7 +95,7 @@ static double tune_rx_and_tx(uhd::usrp::multi_usrp::sptr usrp, const double tx_l
  * Main
  **********************************************************************/
 int UHD_SAFE_MAIN(int argc, char *argv[]){
-    std::string args;
+    std::string args, subdev, serial;
     double tx_wave_freq, tx_wave_ampl, rx_offset;
     double freq_start, freq_stop, freq_step;
     size_t nsamps;
@@ -104,6 +105,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
         ("help", "help message")
         ("verbose", "enable some verbose")
         ("args", po::value<std::string>(&args)->default_value(""), "device address args [default = \"\"]")
+        ("subdev", po::value<std::string>(&subdev), "Subdevice specification (default: first subdevice, often 'A')")
         ("tx_wave_freq", po::value<double>(&tx_wave_freq)->default_value(507.123e3), "Transmit wave frequency in Hz")
         ("tx_wave_ampl", po::value<double>(&tx_wave_ampl)->default_value(0.7), "Transmit wave amplitude in counts")
         ("rx_offset", po::value<double>(&rx_offset)->default_value(.9344e6), "RX LO offset from the TX LO in Hz")
@@ -131,6 +133,15 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     std::cout << boost::format("Creating the usrp device with: %s...") % args << std::endl;
     uhd::usrp::multi_usrp::sptr usrp = uhd::usrp::multi_usrp::make(args);
 
+    // Configure subdev
+    if (vm.count("subdev")) {
+        usrp->set_tx_subdev_spec(subdev);
+        usrp->set_rx_subdev_spec(subdev);
+    }
+    UHD_MSG(status) << "Running calibration for " << usrp->get_tx_subdev_name(0) << std::endl;
+    serial = get_serial(usrp, "tx");
+    UHD_MSG(status) << "Daughterboard serial: " << serial << std::endl;
+
     //set the antennas to cal
     if (not uhd::has(usrp->get_rx_antennas(), "CAL") or not uhd::has(usrp->get_tx_antennas(), "CAL")){
         throw std::runtime_error("This board does not have the CAL antenna option, cannot self-calibrate.");
@@ -160,6 +171,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
 
     if (not vm.count("freq_start")) freq_start = usrp->get_tx_freq_range().start() + 50e6;
     if (not vm.count("freq_stop")) freq_stop = usrp->get_tx_freq_range().stop() - 50e6;
+    UHD_MSG(status) << boost::format("Calibration frequency range: %d MHz -> %d MHz") % (freq_start/1e6) % (freq_stop/1e6) << std::endl;
 
     for (double tx_lo_i = freq_start; tx_lo_i <= freq_stop; tx_lo_i += freq_step){
         const double tx_lo = tune_rx_and_tx(usrp, tx_lo_i, rx_offset);
@@ -235,7 +247,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     threads.interrupt_all();
     threads.join_all();
 
-    store_results(usrp, results, "TX", "tx", "dc");
+    store_results(results, "TX", "tx", "dc", serial);
 
     return EXIT_SUCCESS;
 }
diff --git a/host/utils/uhd_cal_tx_iq_balance.cpp b/host/utils/uhd_cal_tx_iq_balance.cpp
index 20d018e..786aac0 100644
--- a/host/utils/uhd_cal_tx_iq_balance.cpp
+++ b/host/utils/uhd_cal_tx_iq_balance.cpp
@@ -20,6 +20,7 @@
 #include <uhd/utils/safe_main.hpp>
 #include <uhd/utils/paths.hpp>
 #include <uhd/utils/algorithm.hpp>
+#include <uhd/utils/msg.hpp>
 #include <uhd/usrp/multi_usrp.hpp>
 #include <boost/program_options.hpp>
 #include <boost/format.hpp>
@@ -95,7 +96,7 @@ static double tune_rx_and_tx(uhd::usrp::multi_usrp::sptr usrp, const double tx_l
  * Main
  **********************************************************************/
 int UHD_SAFE_MAIN(int argc, char *argv[]){
-    std::string args;
+    std::string args, subdev, serial;
     double tx_wave_freq, tx_wave_ampl, rx_offset;
     double freq_start, freq_stop, freq_step;
     size_t nsamps;
@@ -105,6 +106,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
         ("help", "help message")
         ("verbose", "enable some verbose")
         ("args", po::value<std::string>(&args)->default_value(""), "device address args [default = \"\"]")
+        ("subdev", po::value<std::string>(&subdev), "Subdevice specification (default: first subdevice, often 'A')")
         ("tx_wave_freq", po::value<double>(&tx_wave_freq)->default_value(507.123e3), "Transmit wave frequency in Hz")
         ("tx_wave_ampl", po::value<double>(&tx_wave_ampl)->default_value(0.7), "Transmit wave amplitude in counts")
         ("rx_offset", po::value<double>(&rx_offset)->default_value(.9344e6), "RX LO offset from the TX LO in Hz")
@@ -122,7 +124,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     if (vm.count("help")){
         std::cout << boost::format("USRP Generate TX IQ Balance Calibration Table %s") % desc << std::endl;
         std::cout <<
-            "This application measures leakage between RX and TX on an XCVR daughterboard to self-calibrate.\n"
+            "This application measures leakage between RX and TX on a daughterboard to self-calibrate.\n"
             << std::endl;
         return EXIT_FAILURE;
     }
@@ -132,6 +134,15 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     std::cout << boost::format("Creating the usrp device with: %s...") % args << std::endl;
     uhd::usrp::multi_usrp::sptr usrp = uhd::usrp::multi_usrp::make(args);
 
+    // Configure subdev
+    if (vm.count("subdev")) {
+        usrp->set_tx_subdev_spec(subdev);
+        usrp->set_rx_subdev_spec(subdev);
+    }
+    UHD_MSG(status) << "Running calibration for " << usrp->get_tx_subdev_name(0) << std::endl;
+    serial = get_serial(usrp, "tx");
+    UHD_MSG(status) << "Daughterboard serial: " << serial << std::endl;
+
     //set the antennas to cal
     if (not uhd::has(usrp->get_rx_antennas(), "CAL") or not uhd::has(usrp->get_tx_antennas(), "CAL")){
         throw std::runtime_error("This board does not have the CAL antenna option, cannot self-calibrate.");
@@ -161,6 +172,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
 
     if (not vm.count("freq_start")) freq_start = usrp->get_tx_freq_range().start() + 50e6;
     if (not vm.count("freq_stop")) freq_stop = usrp->get_tx_freq_range().stop() - 50e6;
+    UHD_MSG(status) << boost::format("Calibration frequency range: %d MHz -> %d MHz") % (freq_start/1e6) % (freq_stop/1e6) << std::endl;
 
     for (double tx_lo_i = freq_start; tx_lo_i <= freq_stop; tx_lo_i += freq_step){
         const double tx_lo = tune_rx_and_tx(usrp, tx_lo_i, rx_offset);
@@ -241,7 +253,8 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     threads.interrupt_all();
     threads.join_all();
 
-    store_results(usrp, results, "TX", "tx", "iq");
+    store_results(results, "TX", "tx", "iq", serial);
 
     return EXIT_SUCCESS;
 }
+
diff --git a/host/utils/usrp_cal_utils.hpp b/host/utils/usrp_cal_utils.hpp
index 40626df..5aff5e2 100644
--- a/host/utils/usrp_cal_utils.hpp
+++ b/host/utils/usrp_cal_utils.hpp
@@ -179,27 +179,37 @@ static inline void write_samples_to_file(
     outfile.close();
 }
 
+
 /***********************************************************************
- * Store data to file
+ * Retrieve d'board serial
  **********************************************************************/
-static void store_results(
+static std::string get_serial(
     uhd::usrp::multi_usrp::sptr usrp,
-    const std::vector<result_t> &results,
-    const std::string &XX,
-    const std::string &xx,
-    const std::string &what
+    const std::string &tx_rx
 ){
-    //extract eeprom serial
     uhd::property_tree::sptr tree = usrp->get_device()->get_tree();
-    const uhd::fs_path db_path = "/mboards/0/dboards/A/" + xx + "_eeprom";
+    uhd::usrp::subdev_spec_t subdev_spec = usrp->get_rx_subdev_spec();
+    const uhd::fs_path db_path = "/mboards/0/dboards/" + subdev_spec[0].db_name + "/" + tx_rx + "_eeprom";
     const uhd::usrp::dboard_eeprom_t db_eeprom = tree->access<uhd::usrp::dboard_eeprom_t>(db_path).get();
+    return db_eeprom.serial;
+}
 
+/***********************************************************************
+ * Store data to file
+ **********************************************************************/
+static void store_results(
+    const std::vector<result_t> &results,
+    const std::string &XX, // "TX" or "RX"
+    const std::string &xx, // "tx" or "rx"
+    const std::string &what, // Type of test, e.g. "iq",
+    const std::string &serial
+){
     //make the calibration file path
     fs::path cal_data_path = fs::path(uhd::get_app_path()) / ".uhd";
     fs::create_directory(cal_data_path);
     cal_data_path = cal_data_path / "cal";
     fs::create_directory(cal_data_path);
-    cal_data_path = cal_data_path / str(boost::format("%s_%s_cal_v0.2_%s.csv") % xx % what % db_eeprom.serial);
+    cal_data_path = cal_data_path / str(boost::format("%s_%s_cal_v0.2_%s.csv") % xx % what % serial);
     if (fs::exists(cal_data_path)){
         fs::rename(cal_data_path, cal_data_path.string() + str(boost::format(".%d") % time(NULL)));
     }
@@ -207,7 +217,7 @@ static void store_results(
     //fill the calibration file
     std::ofstream cal_data(cal_data_path.string().c_str());
     cal_data << boost::format("name, %s Frontend Calibration\n") % XX;
-    cal_data << boost::format("serial, %s\n") % db_eeprom.serial;
+    cal_data << boost::format("serial, %s\n") % serial;
     cal_data << boost::format("timestamp, %d\n") % time(NULL);
     cal_data << boost::format("version, 0, 1\n");
     cal_data << boost::format("DATA STARTS HERE\n");
@@ -259,3 +269,4 @@ static void capture_samples(
         throw std::runtime_error("did not get all the samples requested");
     }
 }
+
-- 
1.7.10.4

