From f2fbcfa30edd32e134a23a1e18079f3e354709f1 Mon Sep 17 00:00:00 2001
From: Ben Hilburn <ben.hilburn@ettus.com>
Date: Wed, 21 May 2014 11:56:07 -0700
Subject: [PATCH 27/31] Lots of bit-specific type work to fix compilation on
 older OSes.

---
 host/examples/fpgpio.cpp                           |   31 ++++++++++----------
 host/include/uhd/transport/nirio/nirio_fifo.h      |    1 +
 host/include/uhd/transport/nirio/nirio_quirks.h    |    1 +
 .../uhd/transport/nirio/nirio_resource_manager.h   |    1 +
 host/include/uhd/transport/nirio/niriok_proxy.h    |    1 +
 .../uhd/transport/nirio/niusrprio_session.h        |    1 +
 host/include/uhd/transport/nirio_zero_copy.hpp     |    1 +
 host/lib/usrp/x300/x300_fw_ctrl.cpp                |    4 +--
 host/lib/usrp/x300/x300_impl.cpp                   |   16 +++++-----
 host/lib/usrp/x300/x300_impl.hpp                   |    4 +--
 host/lib/usrp/x300/x300_io_impl.cpp                |    6 ++--
 host/utils/b2xx_fx3_utils.cpp                      |    2 +-
 host/utils/nirio_programmer.cpp                    |    1 +
 host/utils/usrp_n2xx_simple_net_burner.cpp         |   20 ++++++-------
 14 files changed, 49 insertions(+), 41 deletions(-)

diff --git a/host/examples/fpgpio.cpp b/host/examples/fpgpio.cpp
index 89a6ece..151d564 100644
--- a/host/examples/fpgpio.cpp
+++ b/host/examples/fpgpio.cpp
@@ -37,6 +37,7 @@
 #include <uhd/convert.hpp>
 #include <boost/program_options.hpp>
 #include <boost/format.hpp>
+#include <boost/cstdint.hpp>
 #include <boost/thread.hpp>
 #include <csignal>
 #include <iostream>
@@ -72,14 +73,14 @@ void output_reg_values(const std::string bank, const uhd::usrp::multi_usrp::sptr
     for (int i = FPGPIO_NUM_BITS - 1; i >= 0; i--)
         std::cout << (boost::format(" %s%d") % (i < 10 ? " " : "") % i);
     std::cout << std::endl;
-    std::cout << "CTRL:     " << to_bit_string(uint16_t(usrp->get_gpio_attr(bank, std::string("CTRL")))) << std::endl;
-    std::cout << "DDR:      " << to_bit_string(uint16_t(usrp->get_gpio_attr(bank, std::string("DDR")))) << std::endl;
-    std::cout << "ATR_0X:   " << to_bit_string(uint16_t(usrp->get_gpio_attr(bank, std::string("ATR_0X")))) << std::endl;
-    std::cout << "ATR_RX:   " << to_bit_string(uint16_t(usrp->get_gpio_attr(bank, std::string("ATR_RX")))) << std::endl;
-    std::cout << "ATR_TX:   " << to_bit_string(uint16_t(usrp->get_gpio_attr(bank, std::string("ATR_TX")))) << std::endl;
-    std::cout << "ATR_XX:   " << to_bit_string(uint16_t(usrp->get_gpio_attr(bank, std::string("ATR_XX")))) << std::endl;
-    std::cout << "OUT:      " << to_bit_string(uint16_t(usrp->get_gpio_attr(bank, std::string("OUT")))) << std::endl;
-    std::cout << "READBACK: " << to_bit_string(uint16_t(usrp->get_gpio_attr(bank, std::string("READBACK")))) << std::endl;
+    std::cout << "CTRL:     " << to_bit_string(boost::uint16_t(usrp->get_gpio_attr(bank, std::string("CTRL")))) << std::endl;
+    std::cout << "DDR:      " << to_bit_string(boost::uint16_t(usrp->get_gpio_attr(bank, std::string("DDR")))) << std::endl;
+    std::cout << "ATR_0X:   " << to_bit_string(boost::uint16_t(usrp->get_gpio_attr(bank, std::string("ATR_0X")))) << std::endl;
+    std::cout << "ATR_RX:   " << to_bit_string(boost::uint16_t(usrp->get_gpio_attr(bank, std::string("ATR_RX")))) << std::endl;
+    std::cout << "ATR_TX:   " << to_bit_string(boost::uint16_t(usrp->get_gpio_attr(bank, std::string("ATR_TX")))) << std::endl;
+    std::cout << "ATR_XX:   " << to_bit_string(boost::uint16_t(usrp->get_gpio_attr(bank, std::string("ATR_XX")))) << std::endl;
+    std::cout << "OUT:      " << to_bit_string(boost::uint16_t(usrp->get_gpio_attr(bank, std::string("OUT")))) << std::endl;
+    std::cout << "READBACK: " << to_bit_string(boost::uint16_t(usrp->get_gpio_attr(bank, std::string("READBACK")))) << std::endl;
 }
 
 int UHD_SAFE_MAIN(int argc, char *argv[]){
@@ -124,13 +125,13 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
     output_reg_values(fpgpio, usrp);
 
     //configure GPIO registers
-    uint32_t ctrl = 0;      // default all as manual
-    uint32_t ddr = 0;       // default all as input
-    uint32_t atr_idle = 0;
-    uint32_t atr_rx = 0;
-    uint32_t atr_tx = 0;
-    uint32_t atr_duplex = 0;
-    uint32_t mask = 0x7ff;
+    boost::uint32_t ctrl = 0;      // default all as manual
+    boost::uint32_t ddr = 0;       // default all as input
+    boost::uint32_t atr_idle = 0;
+    boost::uint32_t atr_rx = 0;
+    boost::uint32_t atr_tx = 0;
+    boost::uint32_t atr_duplex = 0;
+    boost::uint32_t mask = 0x7ff;
 
     //set up FPGPIO outputs:
     //FPGPIO[0] = ATR output 1 at idle
diff --git a/host/include/uhd/transport/nirio/nirio_fifo.h b/host/include/uhd/transport/nirio/nirio_fifo.h
index fc1de24..14ebeef 100644
--- a/host/include/uhd/transport/nirio/nirio_fifo.h
+++ b/host/include/uhd/transport/nirio/nirio_fifo.h
@@ -19,6 +19,7 @@
 #ifndef INCLUDED_UHD_TRANSPORT_NIRIO_NIRIO_FIFO_H
 #define INCLUDED_UHD_TRANSPORT_NIRIO_NIRIO_FIFO_H
 
+#include <stdint.h>
 #include <uhd/transport/nirio/nirio_driver_iface.h>
 #include <uhd/transport/nirio/niriok_proxy.h>
 #include <uhd/transport/nirio/status.h>
diff --git a/host/include/uhd/transport/nirio/nirio_quirks.h b/host/include/uhd/transport/nirio/nirio_quirks.h
index ed4f72e..8e58f80 100644
--- a/host/include/uhd/transport/nirio/nirio_quirks.h
+++ b/host/include/uhd/transport/nirio/nirio_quirks.h
@@ -20,6 +20,7 @@
 #define INCLUDED_UHD_TRANSPORT_NIRIO_NIRIO_QUIRKS_H
 
 #include <set>
+#include <stdint.h>
 #include <uhd/utils/log.hpp>
 
 //Quirk#1: We need to verify RX zero-copy data transfers from the RIO
diff --git a/host/include/uhd/transport/nirio/nirio_resource_manager.h b/host/include/uhd/transport/nirio/nirio_resource_manager.h
index a10b3d5..8c0e373 100644
--- a/host/include/uhd/transport/nirio/nirio_resource_manager.h
+++ b/host/include/uhd/transport/nirio/nirio_resource_manager.h
@@ -24,6 +24,7 @@
 #include <vector>
 #include <map>
 #include <string>
+#include <stdint.h>
 
 namespace uhd { namespace niusrprio
 {
diff --git a/host/include/uhd/transport/nirio/niriok_proxy.h b/host/include/uhd/transport/nirio/niriok_proxy.h
index ca6a4ba..85eaf31 100644
--- a/host/include/uhd/transport/nirio/niriok_proxy.h
+++ b/host/include/uhd/transport/nirio/niriok_proxy.h
@@ -18,6 +18,7 @@
 #ifndef INCLUDED_UHD_TRANSPORT_NIRIO_NIRIO_INTERFACE_H
 #define INCLUDED_UHD_TRANSPORT_NIRIO_NIRIO_INTERFACE_H
 
+#include <stdint.h>
 #include <boost/smart_ptr.hpp>
 #include <boost/noncopyable.hpp>
 #include <uhd/transport/nirio/nirio_driver_iface.h>
diff --git a/host/include/uhd/transport/nirio/niusrprio_session.h b/host/include/uhd/transport/nirio/niusrprio_session.h
index c84bc75..a684d98 100644
--- a/host/include/uhd/transport/nirio/niusrprio_session.h
+++ b/host/include/uhd/transport/nirio/niusrprio_session.h
@@ -19,6 +19,7 @@
 #ifndef INCLUDED_UHD_TRANSPORT_NIRIO_NIUSRPRIO_SESSION_H
 #define INCLUDED_UHD_TRANSPORT_NIRIO_NIUSRPRIO_SESSION_H
 
+#include <stdint.h>
 #include <uhd/transport/nirio/rpc/usrprio_rpc_client.hpp>
 #include <uhd/transport/nirio/niriok_proxy.h>
 #include <uhd/transport/nirio/nirio_resource_manager.h>
diff --git a/host/include/uhd/transport/nirio_zero_copy.hpp b/host/include/uhd/transport/nirio_zero_copy.hpp
index 5b16b19..fc3ccf5 100644
--- a/host/include/uhd/transport/nirio_zero_copy.hpp
+++ b/host/include/uhd/transport/nirio_zero_copy.hpp
@@ -23,6 +23,7 @@
 #include <uhd/transport/zero_copy.hpp>
 #include <uhd/types/device_addr.hpp>
 #include <boost/shared_ptr.hpp>
+#include <stdint.h>
 
 namespace uhd{ namespace transport{
 
diff --git a/host/lib/usrp/x300/x300_fw_ctrl.cpp b/host/lib/usrp/x300/x300_fw_ctrl.cpp
index 67c314d..804d23f 100644
--- a/host/lib/usrp/x300/x300_fw_ctrl.cpp
+++ b/host/lib/usrp/x300/x300_fw_ctrl.cpp
@@ -285,8 +285,8 @@ protected:
 
 private:
     niriok_proxy& _drv_proxy;
-    static const uint32_t READ_TIMEOUT_IN_MS = 10;
-    static const uint32_t INIT_TIMEOUT_IN_MS = 5000;
+    static const boost::uint32_t READ_TIMEOUT_IN_MS = 10;
+    static const boost::uint32_t INIT_TIMEOUT_IN_MS = 5000;
 };
 
 wb_iface::sptr x300_make_ctrl_iface_enet(uhd::transport::udp_simple::sptr udp)
diff --git a/host/lib/usrp/x300/x300_impl.cpp b/host/lib/usrp/x300/x300_impl.cpp
index 698d98f..2c291f4 100644
--- a/host/lib/usrp/x300/x300_impl.cpp
+++ b/host/lib/usrp/x300/x300_impl.cpp
@@ -409,7 +409,7 @@ void x300_impl::setup_mb(const size_t mb_i, const uhd::device_addr_t &dev_addr)
         nirio_status_to_exception(status, "x300_impl: Could not initialize RIO session.");
 
         //Tell the quirks object which FIFOs carry TX stream data
-        const uint32_t tx_data_fifos[2] = {X300_RADIO_DEST_PREFIX_TX, X300_RADIO_DEST_PREFIX_TX + 3};
+        const boost::uint32_t tx_data_fifos[2] = {X300_RADIO_DEST_PREFIX_TX, X300_RADIO_DEST_PREFIX_TX + 3};
         mb.rio_fpga_interface->get_kernel_proxy().get_rio_quirks().register_tx_streams(tx_data_fifos);
 
         _tree->create<double>(mb_path / "link_max_rate").set(X300_MAX_RATE_PCIE);
@@ -894,7 +894,7 @@ void x300_impl::setup_radio(const size_t mb_i, const std::string &slot_name)
     ////////////////////////////////////////////////////////////////////
     // radio control
     ////////////////////////////////////////////////////////////////////
-    uint8_t dest = (radio_index == 0)? X300_XB_DST_R0 : X300_XB_DST_R1;
+    boost::uint8_t dest = (radio_index == 0)? X300_XB_DST_R0 : X300_XB_DST_R1;
     boost::uint32_t ctrl_sid;
     both_xports_t xport = this->make_transport(mb_i, dest, X300_RADIO_DEST_PREFIX_CTRL, device_addr_t(), ctrl_sid);
     perif.ctrl = radio_ctrl_core_3000::make(mb.if_pkt_is_big_endian, xport.recv, xport.send, ctrl_sid, slot_name);
@@ -1103,8 +1103,8 @@ boost::uint32_t get_pcie_dma_channel(boost::uint8_t destination, boost::uint8_t
 
 x300_impl::both_xports_t x300_impl::make_transport(
     const size_t mb_index,
-    const uint8_t& destination,
-    const uint8_t& prefix,
+    const boost::uint8_t& destination,
+    const boost::uint8_t& prefix,
     const uhd::device_addr_t& args,
     boost::uint32_t& sid
 )
@@ -1302,7 +1302,7 @@ boost::uint32_t x300_impl::allocate_sid(mboard_members_t &mb, const sid_config_t
     mb.zpu_ctrl->poke32(SR_ADDR(SETXB_BASE, 0 + (X300_DEVICE_HERE)), config.router_dst_here);
 
     if (xport_path == "nirio") {
-        uint32_t router_config_word = ((_sid_framer & 0xff) << 16) |                                    //Return SID
+        boost::uint32_t router_config_word = ((_sid_framer & 0xff) << 16) |                                    //Return SID
                                       get_pcie_dma_channel(config.router_dst_there, config.dst_prefix); //Dest
         mb.rio_fpga_interface->get_kernel_proxy().poke(PCIE_ROUTER_REG(0), router_config_word);
     }
@@ -1439,7 +1439,7 @@ void x300_impl::wait_for_ref_locked(wb_iface::sptr ctrl, double timeout)
 
 sensor_value_t x300_impl::get_ref_locked(wb_iface::sptr ctrl)
 {
-    uint32_t clk_status = ctrl->peek32(SR_ADDR(SET0_BASE, ZPU_RB_CLK_STATUS));
+    boost::uint32_t clk_status = ctrl->peek32(SR_ADDR(SET0_BASE, ZPU_RB_CLK_STATUS));
     const bool lock = ((clk_status & ZPU_RB_CLK_STATUS_LMK_LOCK) != 0);
     return sensor_value_t("Ref", lock, "locked", "unlocked");
 }
@@ -1448,11 +1448,11 @@ bool x300_impl::is_pps_present(wb_iface::sptr ctrl)
 {
     // The ZPU_RB_CLK_STATUS_PPS_DETECT bit toggles with each rising edge of the PPS.
     // We monitor it for up to 1.5 seconds looking for it to toggle.
-    uint32_t pps_detect = ctrl->peek32(SR_ADDR(SET0_BASE, ZPU_RB_CLK_STATUS)) & ZPU_RB_CLK_STATUS_PPS_DETECT;
+    boost::uint32_t pps_detect = ctrl->peek32(SR_ADDR(SET0_BASE, ZPU_RB_CLK_STATUS)) & ZPU_RB_CLK_STATUS_PPS_DETECT;
     for (int i = 0; i < 15; i++)
     {
         boost::this_thread::sleep(boost::posix_time::milliseconds(100));
-        uint32_t clk_status = ctrl->peek32(SR_ADDR(SET0_BASE, ZPU_RB_CLK_STATUS));
+        boost::uint32_t clk_status = ctrl->peek32(SR_ADDR(SET0_BASE, ZPU_RB_CLK_STATUS));
         if (pps_detect != (clk_status & ZPU_RB_CLK_STATUS_PPS_DETECT))
             return true;
     }
diff --git a/host/lib/usrp/x300/x300_impl.hpp b/host/lib/usrp/x300/x300_impl.hpp
index 90aed2f..80f3e8f 100644
--- a/host/lib/usrp/x300/x300_impl.hpp
+++ b/host/lib/usrp/x300/x300_impl.hpp
@@ -273,8 +273,8 @@ private:
     };
     both_xports_t make_transport(
         const size_t mb_index,
-        const uint8_t& destination,
-        const uint8_t& prefix,
+        const boost::uint8_t& destination,
+        const boost::uint8_t& prefix,
         const uhd::device_addr_t& args,
         boost::uint32_t& sid);
 
diff --git a/host/lib/usrp/x300/x300_io_impl.cpp b/host/lib/usrp/x300/x300_io_impl.cpp
index 9263c9b..500a24f 100644
--- a/host/lib/usrp/x300/x300_io_impl.cpp
+++ b/host/lib/usrp/x300/x300_io_impl.cpp
@@ -265,7 +265,7 @@ static void handle_tx_async_msgs(boost::shared_ptr<x300_tx_fc_guts_t> guts, zero
     const boost::uint32_t *packet_buff = buff->cast<const boost::uint32_t *>();
 
     //unpacking can fail
-    uint32_t (*endian_conv)(uint32_t) = uhd::ntohx;
+    boost::uint32_t (*endian_conv)(boost::uint32_t) = uhd::ntohx;
     try
     {
         if (big_endian)
@@ -402,7 +402,7 @@ rx_streamer::sptr x300_impl::get_rx_stream(const uhd::stream_args_t &args_)
         }
 
         //allocate sid and create transport
-        uint8_t dest = (radio_index == 0)? X300_XB_DST_R0 : X300_XB_DST_R1;
+        boost::uint8_t dest = (radio_index == 0)? X300_XB_DST_R0 : X300_XB_DST_R1;
         boost::uint32_t data_sid;
         UHD_LOG << "creating rx stream " << device_addr.to_string() << std::endl;
         both_xports_t xport = this->make_transport(mb_index, dest, X300_RADIO_DEST_PREFIX_RX, device_addr, data_sid);
@@ -565,7 +565,7 @@ tx_streamer::sptr x300_impl::get_tx_stream(const uhd::stream_args_t &args_)
         device_addr_t device_addr = mb.send_args;
 
         //allocate sid and create transport
-        uint8_t dest = (radio_index == 0)? X300_XB_DST_R0 : X300_XB_DST_R1;
+        boost::uint8_t dest = (radio_index == 0)? X300_XB_DST_R0 : X300_XB_DST_R1;
         boost::uint32_t data_sid;
         UHD_LOG << "creating tx stream " << device_addr.to_string() << std::endl;
         both_xports_t xport = this->make_transport(mb_index, dest, X300_RADIO_DEST_PREFIX_TX, device_addr, data_sid);
diff --git a/host/utils/b2xx_fx3_utils.cpp b/host/utils/b2xx_fx3_utils.cpp
index d5f829c..0d0eaa7 100644
--- a/host/utils/b2xx_fx3_utils.cpp
+++ b/host/utils/b2xx_fx3_utils.cpp
@@ -535,7 +535,7 @@ boost::int32_t main(boost::int32_t argc, char *argv[]) {
 
     } else if (vm.count("load-fpga")) {
         std::cout << "Loading FPGA image (" << fpga_file << ")" << std::endl;
-        uint32_t fx3_state;
+        boost::uint32_t fx3_state;
         try {fx3_state = b200->load_fpga(fpga_file);} // returns 0 on success, or FX3 state on error
         catch (uhd::exception &e) {
             std::cerr << "Exception while loading FPGA: " << e.what() << std::endl;
diff --git a/host/utils/nirio_programmer.cpp b/host/utils/nirio_programmer.cpp
index 98db862..199c081 100644
--- a/host/utils/nirio_programmer.cpp
+++ b/host/utils/nirio_programmer.cpp
@@ -4,6 +4,7 @@
 #include <uhd/transport/nirio/nifpga_lvbitx.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <fcntl.h>
 #include <iostream>
 #include <fstream>
diff --git a/host/utils/usrp_n2xx_simple_net_burner.cpp b/host/utils/usrp_n2xx_simple_net_burner.cpp
index cecac55..0234ce6 100644
--- a/host/utils/usrp_n2xx_simple_net_burner.cpp
+++ b/host/utils/usrp_n2xx_simple_net_burner.cpp
@@ -93,20 +93,20 @@ typedef enum {
 } usrp2_fw_update_id_t;
 
 typedef struct {
-    uint32_t proto_ver;
-    uint32_t id;
-    uint32_t seq;
+    boost::uint32_t proto_ver;
+    boost::uint32_t id;
+    boost::uint32_t seq;
     union {
-        uint32_t ip_addr;
-        uint32_t hw_rev;
+        boost::uint32_t ip_addr;
+        boost::uint32_t hw_rev;
         struct {
-            uint32_t flash_addr;
-            uint32_t length;
-            uint8_t  data[256];
+            boost::uint32_t flash_addr;
+            boost::uint32_t length;
+            boost::uint8_t  data[256];
         } flash_args;
         struct {
-            uint32_t sector_size_bytes;
-            uint32_t memory_size_bytes;
+            boost::uint32_t sector_size_bytes;
+            boost::uint32_t memory_size_bytes;
         } flash_info_args;
     } data;
 } usrp2_fw_update_data_t;
-- 
1.7.10.4

