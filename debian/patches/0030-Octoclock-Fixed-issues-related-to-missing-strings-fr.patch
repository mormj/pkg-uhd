From e1dec92e3c142a6b4846834afad99185b73189c6 Mon Sep 17 00:00:00 2001
From: michael-west <michael.west@ettus.com>
Date: Tue, 28 Jun 2016 17:09:53 -0700
Subject: [PATCH 30/42] Octoclock: Fixed issues related to missing strings from
 GPSDO. - Corrected case when num_wraps overflowed - Added limit to cache age

---
 host/lib/usrp_clock/octoclock/octoclock_uart.cpp | 38 ++++++++++++++++--------
 host/lib/usrp_clock/octoclock/octoclock_uart.hpp |  1 +
 2 files changed, 26 insertions(+), 13 deletions(-)

diff --git a/host/lib/usrp_clock/octoclock/octoclock_uart.cpp b/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
index bc2c9b6..221a7e4 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
@@ -37,8 +37,7 @@ using namespace uhd::transport;
 #define NUM_WRAPS_EQUAL   (_state.num_wraps == _device_state.num_wraps)
 #define POS_EQUAL         (_state.pos == _device_state.pos)
 #define STATES_EQUAL      (NUM_WRAPS_EQUAL && POS_EQUAL)
-#define LOCAL_STATE_AHEAD (_state.num_wraps > _device_state.num_wraps || \
-                           (NUM_WRAPS_EQUAL && _state.pos > _device_state.pos))
+#define MAX_CACHE_AGE     256   //seconds
 
 namespace uhd{
     octoclock_uart_iface::octoclock_uart_iface(udp_simple::sptr udp, uint32_t proto_ver): uart_iface(){
@@ -88,10 +87,15 @@ namespace uhd{
 
     std::string octoclock_uart_iface::read_uart(double timeout){
         std::string result;
-
+        bool first_time = true;
         boost::system_time exit_time = boost::get_system_time() + boost::posix_time::milliseconds(long(timeout*1e3));
 
         while(boost::get_system_time() < exit_time){
+            if (first_time)
+                first_time = false;
+            else
+                boost::this_thread::sleep(boost::posix_time::milliseconds(1));
+
             _update_cache();
 
             for(char ch = _getchar(); ch != 0; ch = _getchar()){
@@ -105,7 +109,6 @@ namespace uhd{
                     return result;
                 }
             }
-            boost::this_thread::sleep(boost::posix_time::milliseconds(1));
         }
 
         return result;
@@ -119,35 +122,44 @@ namespace uhd{
         boost::uint8_t octoclock_data[udp_simple::mtu];
         const octoclock_packet_t *pkt_in = reinterpret_cast<octoclock_packet_t*>(octoclock_data);
 
-        if(STATES_EQUAL or LOCAL_STATE_AHEAD){
+        if(STATES_EQUAL){
+            boost::system_time time = boost::get_system_time();
+            boost::posix_time::time_duration age = time - _last_cache_update;
+            bool cache_expired = (age > boost::posix_time::seconds(MAX_CACHE_AGE));
+
             pkt_out.sequence = uhd::htonx<boost::uint32_t>(++_sequence);
             UHD_OCTOCLOCK_SEND_AND_RECV(_udp, _proto_ver, SEND_GPSDO_CACHE_CMD, pkt_out, len, octoclock_data);
             if(UHD_OCTOCLOCK_PACKET_MATCHES(SEND_GPSDO_CACHE_ACK, pkt_out, pkt_in, len)){
                 memcpy(&_cache[0], pkt_in->data, _poolsize);
                 _device_state = pkt_in->state;
+                _last_cache_update = time;
             }
 
             boost::uint8_t delta_wraps = (_device_state.num_wraps - _state.num_wraps);
-            if(delta_wraps > 1 or
-               ((delta_wraps == 1) and (_device_state.pos >= _state.pos))){
+            if(cache_expired or delta_wraps > 1 or
+               ((delta_wraps == 1) and (_device_state.pos > _state.pos))){
 
-                _state.pos = (_device_state.pos+1) % _poolsize;
+                _state.pos = _device_state.pos;
                 _state.num_wraps = (_device_state.num_wraps-1);
+                _rxbuff.clear();
 
-                while((_cache[_state.pos] != '\n') and (_state.pos != _device_state.pos)){
+                while((_cache[_state.pos] != '\n')){
+                    _state.pos = (_state.pos+1) % _poolsize;
+                    //We may have wrapped around locally
+                    if(_state.pos == 0) _state.num_wraps++;
+                    if(STATES_EQUAL) break;
+                }
+                if (_cache[_state.pos] == '\n'){
                     _state.pos = (_state.pos+1) % _poolsize;
                     //We may have wrapped around locally
                     if(_state.pos == 0) _state.num_wraps++;
                 }
-                if (_cache[_state.pos] == '\n') _state.pos = (_state.pos+1) % _poolsize;
-                //We may have wrapped around locally
-                if(_state.pos == 0) _state.num_wraps++;
             }
         }
     }
 
     char octoclock_uart_iface::_getchar(){
-        if(STATES_EQUAL or LOCAL_STATE_AHEAD){
+        if(STATES_EQUAL){
             return 0;
         }
 
diff --git a/host/lib/usrp_clock/octoclock/octoclock_uart.hpp b/host/lib/usrp_clock/octoclock/octoclock_uart.hpp
index 360e536..d3a9738 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_uart.hpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_uart.hpp
@@ -47,6 +47,7 @@ private:
     std::string _rxbuff;
     boost::uint32_t _sequence;
 	boost::uint32_t _proto_ver;
+    boost::system_time _last_cache_update;
 
     void _update_cache();
     char _getchar();
-- 
2.1.4

