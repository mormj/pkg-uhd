From 59ed6e1a0f9710c7bfca0a348d07f8c96f9f6bc0 Mon Sep 17 00:00:00 2001
From: michael-west <michael.west@ettus.com>
Date: Mon, 18 Jul 2016 14:34:00 -0700
Subject: [PATCH 04/30] GPSDO: Make sure read_uart() returns only complete
 strings for all devices.

---
 host/include/uhd/types/serial.hpp                | 15 +++++++--------
 host/lib/transport/udp_simple.cpp                | 14 +++++++++++---
 host/lib/usrp/b200/b200_uart.cpp                 | 23 +++++++++++++----------
 host/lib/usrp/e100/e100_ctrl.cpp                 | 17 ++++++++++++-----
 host/lib/usrp/x300/x300_fw_uart.cpp              |  4 ++++
 host/lib/usrp_clock/octoclock/octoclock_uart.cpp |  1 +
 6 files changed, 48 insertions(+), 26 deletions(-)

diff --git a/host/include/uhd/types/serial.hpp b/host/include/uhd/types/serial.hpp
index 7b565c6..dca0cfb 100644
--- a/host/include/uhd/types/serial.hpp
+++ b/host/include/uhd/types/serial.hpp
@@ -124,7 +124,7 @@ namespace uhd{
          */
         spi_config_t(edge_t edge = EDGE_RISE);
     };
-    
+
     /*!
      * The SPI interface class.
      * Provides routines to transact SPI and do other useful things which haven't been defined yet.
@@ -151,12 +151,12 @@ namespace uhd{
             size_t num_bits,
             bool readback
         ) = 0;
-        
+
         /*!
         * Read from the SPI bus.
         * \param which_slave the slave device number
         * \param config spi config args
-        * \param data the bits to write out (be sure to set write bit) 
+        * \param data the bits to write out (be sure to set write bit)
         * \param num_bits how many bits in data
         * \return spi data
         */
@@ -166,7 +166,7 @@ namespace uhd{
             boost::uint32_t data,
             size_t num_bits
         );
-        
+
         /*!
         * Write to the SPI bus.
         * \param which_slave the slave device number
@@ -183,7 +183,7 @@ namespace uhd{
     };
 
     /*!
-     * UART interface to write and read bytes.
+     * UART interface to write and read strings.
      */
     class UHD_API uart_iface{
     public:
@@ -198,10 +198,9 @@ namespace uhd{
         virtual void write_uart(const std::string &buf) = 0;
 
         /*!
-         * Read from a serial port.
-         * Reads until complete line or timeout.
+         * Read a line from a serial port.
          * \param timeout the timeout in seconds
-         * \return the data read from the serial port
+         * \return the line or empty string upon timeout
          */
         virtual std::string read_uart(double timeout) = 0;
     };
diff --git a/host/lib/transport/udp_simple.cpp b/host/lib/transport/udp_simple.cpp
index 347373c..8b6e5eb 100644
--- a/host/lib/transport/udp_simple.cpp
+++ b/host/lib/transport/udp_simple.cpp
@@ -114,9 +114,16 @@ public:
         do{
             //drain anything in current buffer
             while (_off < _len){
-                const char ch = _buf[_off]; _off++;
-                line += std::string(1, ch);
-                if (ch == '\n' or ch == '\r') return line;
+                const char ch = _buf[_off++];
+                if (ch == '\r') continue;
+                if (ch == '\n' and _line.empty()) continue;
+                _line += ch;
+                if (ch == '\n')
+                {
+                    line = _line;
+                    _line.clear();
+                    return line;
+                }
             }
 
             //recv a new packet into the buffer
@@ -131,6 +138,7 @@ private:
     udp_simple::sptr _udp;
     size_t _len, _off;
     boost::uint8_t _buf[udp_simple::mtu];
+    std::string _line;
 };
 
 uhd::uart_iface::sptr udp_simple::make_uart(sptr udp){
diff --git a/host/lib/usrp/b200/b200_uart.cpp b/host/lib/usrp/b200/b200_uart.cpp
index 4682a79..f86b416 100644
--- a/host/lib/usrp/b200/b200_uart.cpp
+++ b/host/lib/usrp/b200/b200_uart.cpp
@@ -32,7 +32,7 @@ struct b200_uart_impl : b200_uart
         _xport(xport),
         _sid(sid),
         _count(0),
-        _char_queue(4096)
+        _line_queue(4096)
     {
         //this default baud divider is over 9000
         this->set_baud_divider(9001);
@@ -77,13 +77,7 @@ struct b200_uart_impl : b200_uart
     std::string read_uart(double timeout)
     {
         std::string line;
-        char ch = '\0';
-        while (_char_queue.pop_with_timed_wait(ch, timeout))
-        {
-            if (ch == '\r') continue;
-            line += std::string(&ch, 1);
-            if (ch == '\n') return line;
-        }
+        _line_queue.pop_with_timed_wait(line, timeout);
         return line;
     }
 
@@ -95,7 +89,15 @@ struct b200_uart_impl : b200_uart
         packet_info.num_packet_words32 = buff->size()/sizeof(boost::uint32_t);
         vrt::if_hdr_unpack_le(packet_buff, packet_info);
         const char ch = char(uhd::wtohx(packet_buff[packet_info.num_header_words32+1]));
-        _char_queue.push_with_pop_on_full(ch);
+        if (ch != '\r')
+            _line += ch;
+        if (ch == '\n')
+        {
+            // Don't store empty strings
+            if (_line.length() > 1)
+                _line_queue.push_with_pop_on_full(_line);
+            _line.clear();
+        }
     }
 
     void set_baud_divider(const double baud_div)
@@ -107,7 +109,8 @@ struct b200_uart_impl : b200_uart
     const boost::uint32_t _sid;
     size_t _count;
     size_t _baud_div;
-    bounded_buffer<char> _char_queue;
+    bounded_buffer<std::string> _line_queue;
+    std::string _line;
 };
 
 
diff --git a/host/lib/usrp/e100/e100_ctrl.cpp b/host/lib/usrp/e100/e100_ctrl.cpp
index cdbbff6..3b59a93 100644
--- a/host/lib/usrp/e100/e100_ctrl.cpp
+++ b/host/lib/usrp/e100/e100_ctrl.cpp
@@ -232,10 +232,15 @@ public:
 
             //got a character -> process it
             if (ret == 1){
-                const bool flush  = ch == '\n' or ch == '\r';
-                if (flush and line.empty()) continue; //avoid flushing on empty lines
-                line += std::string(1, ch);
-                if (flush) break;
+                if (ch == '\r') continue;
+                if (ch == '\n' and _line.empty()) continue;
+                _line += ch;
+                if (ch == '\n')
+                {
+                    line = _line;
+                    _line.clear();
+                    break;
+                }
             }
 
             //didnt get a character, check the timeout
@@ -251,7 +256,9 @@ public:
         return line;
     }
 
-private: int _node_fd;
+private:
+    int _node_fd;
+    std::string _line;
 };
 
 uhd::uart_iface::sptr e100_ctrl::make_gps_uart_iface(const std::string &node){
diff --git a/host/lib/usrp/x300/x300_fw_uart.cpp b/host/lib/usrp/x300/x300_fw_uart.cpp
index b0fae12..86141ca 100644
--- a/host/lib/usrp/x300/x300_fw_uart.cpp
+++ b/host/lib/usrp/x300/x300_fw_uart.cpp
@@ -132,6 +132,10 @@ struct x300_uart_iface : uart_iface
                 if (ch == '\r')
                     continue;
 
+                // avoid returning empty strings
+                if (ch == '\n' and _rxbuff.empty())
+                    continue;
+
                 // store character to buffer
                 _rxbuff += std::string(1, (char)ch);
 
diff --git a/host/lib/usrp_clock/octoclock/octoclock_uart.cpp b/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
index 221a7e4..538ee06 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
@@ -100,6 +100,7 @@ namespace uhd{
 
             for(char ch = _getchar(); ch != 0; ch = _getchar()){
                 if(ch == '\r') continue; //Skip carriage returns
+                if(ch == '\n' and _rxbuff.empty()) continue; //Skip empty lines
                 _rxbuff += ch;
 
                 //If newline found, return string
-- 
2.1.4

