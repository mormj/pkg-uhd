From 093412e6c7c2450c4a52ebf490ef540f9e0f17d0 Mon Sep 17 00:00:00 2001
From: Martin Braun <martin.braun@ettus.com>
Date: Tue, 6 Mar 2018 15:45:15 -0800
Subject: [PATCH 10/40] mpm: Fix some Pylint warnings

No functional changes.
---
 mpm/python/usrp_mpm/chips/lmk04828.py           | 17 ++++---
 mpm/python/usrp_mpm/cores/nijesdcore.py         | 59 ++++++++++++-------------
 mpm/python/usrp_mpm/cores/tdc_sync.py           |  8 ++--
 mpm/python/usrp_mpm/dboard_manager/lmk_mg.py    | 11 ++---
 mpm/python/usrp_mpm/dboard_manager/magnesium.py | 12 ++---
 mpm/python/usrp_mpm/discovery.py                |  4 +-
 mpm/python/usrp_mpm/periph_manager/base.py      |  1 -
 7 files changed, 57 insertions(+), 55 deletions(-)

diff --git a/mpm/python/usrp_mpm/chips/lmk04828.py b/mpm/python/usrp_mpm/chips/lmk04828.py
index 5075f1bbf..0611ec777 100644
--- a/mpm/python/usrp_mpm/chips/lmk04828.py
+++ b/mpm/python/usrp_mpm/chips/lmk04828.py
@@ -86,28 +86,31 @@ class LMK04828(object):
         cnth = int(math.floor(divide_val/2.0))
         reg_val = ((cnth & 0xF) << 4) | (cntl & 0xF)
         self.log.trace("From divider value 0d{}, writing CNTH/L as 0x{:02X}."
-           .format(divide_val, reg_val))
+                       .format(divide_val, reg_val))
         return reg_val
 
-    def divide_to_reg(self, divide_val, in_drive = 0x1, out_drive = 0x1):
+    def divide_to_reg(self, divide_val, in_drive=0x1, out_drive=0x1):
         """
         From the divider value, returns the register value combined with the other
         register fields.
         """
         reg_val = (divide_val & 0x1F) | ((in_drive & 0x1) << 5) | ((out_drive & 0x1) << 6)
         self.log.trace("From divider value 0d{}, writing divider register as 0x{:02X}."
-           .format(divide_val, reg_val))
+                       .format(divide_val, reg_val))
         return reg_val
 
-    def pll2_pre_to_reg(self, prescaler, osc_field = 0x01, xtal_en = 0x0, ref_2x_en = 0x0):
+    def pll2_pre_to_reg(self, prescaler, osc_field=0x01, xtal_en=0x0, ref_2x_en=0x0):
         """
         From the prescaler value, returns the register value combined with the other
         register fields.
         """
         # valid prescaler values are 2-8, where 8 is represented as 0x00.
-        assert prescaler in range(2,8+1)
-        reg_val = ((prescaler & 0x07) << 5) | ((osc_field & 0x7) << 2) | ((xtal_en & 0x1) << 1) | ((ref_2x_en & 0x1) << 0)
+        assert prescaler in range(2, 8+1)
+        reg_val = ((prescaler & 0x07) << 5) \
+                  | ((osc_field & 0x7) << 2) \
+                  | ((xtal_en & 0x1) << 1) \
+                  | ((ref_2x_en & 0x1) << 0)
         self.log.trace("From prescaler value 0d{}, writing register as 0x{:02X}."
-           .format(prescaler, reg_val))
+                       .format(prescaler, reg_val))
         return reg_val
 
diff --git a/mpm/python/usrp_mpm/cores/nijesdcore.py b/mpm/python/usrp_mpm/cores/nijesdcore.py
index bf2bde6e9..13fd25dbf 100644
--- a/mpm/python/usrp_mpm/cores/nijesdcore.py
+++ b/mpm/python/usrp_mpm/cores/nijesdcore.py
@@ -208,7 +208,7 @@ class NIMgJESDCore(object):
         self.log.trace("%s FPGA SYSREF Receiver..." % {True: 'Enabling', False: 'Disabling'}[enable])
         disable_bit = 0b1
         if enable:
-           disable_bit = 0b0
+            disable_bit = 0b0
         reg_val = ((self.lmfc_divider-1) << 23) | (disable_bit << 6)
         self.log.trace("Setting SYSREF Capture reg: 0x{:08X}".format(reg_val))
         self.regs.poke32(self.SYSREF_CAPTURE_CONTROL, reg_val)
@@ -252,9 +252,9 @@ class NIMgJESDCore(object):
         # Power down state is when the corresponding bit is set. For the PLLs we wish to
         # use, clear those bits.
         for x in range(qplls):
-           reg_val_on = reg_val_on | 0x1 << x # QPLL bits are 0-3
+            reg_val_on = reg_val_on | 0x1 << x # QPLL bits are 0-3
         for y in range(16, 16 + cplls):
-           reg_val_on = reg_val_on | 0x1 << y # CPLL bits are 16-23, others are reserved
+            reg_val_on = reg_val_on | 0x1 << y # CPLL bits are 16-23, others are reserved
         reg_val = reg_val ^ reg_val_on
         self.regs.poke32(self.MGT_PLL_POWER_DOWN_CONTROL, reg_val)
 
@@ -281,31 +281,31 @@ class NIMgJESDCore(object):
 
         # Unreset the PLLs in use and check for lock.
         if not reset_only:
-           if qplls > 0:
-              # Unreset only the QPLLs we are using.
-              reg_val_on = 0x0
-              for nibble in range(qplls):
-                 reg_val_on = reg_val_on | 0x1 << nibble*4
-              reg_val = reg_val ^ reg_val_on
-              self.regs.poke32(self.MGT_QPLL_CONTROL, reg_val)
-              self.log.trace("Clearing QPLL reset...")
+            if qplls > 0:
+                # Unreset only the QPLLs we are using.
+                reg_val_on = 0x0
+                for nibble in range(qplls):
+                    reg_val_on = reg_val_on | 0x1 << nibble*4
+                reg_val = reg_val ^ reg_val_on
+                self.regs.poke32(self.MGT_QPLL_CONTROL, reg_val)
+                self.log.trace("Clearing QPLL reset...")
 
-              # Check for lock a short time later.
-              time.sleep(0.010)
-              # Clear all QPLL sticky bits
-              self.regs.poke32(self.MGT_QPLL_CONTROL, 0b1 << 16)
-              # Check for lock on active quads only.
-              rb = self.regs.peek32(self.MGT_QPLL_CONTROL)
-              rb_mask = 0x0
-              locked_val = 0x0
-              for nibble in range(qplls):
-                 if (rb & (0xF << nibble*4)) != (0x2 << nibble*4):
-                    self.log.warning("GT QPLL {} failed to lock!".format(nibble))
-                 locked_val = locked_val | 0x2 << nibble*4
-                 rb_mask    = rb_mask    | 0xF << nibble*4
-              if (rb & rb_mask) != locked_val:
-                  raise RuntimeError("One or more GT QPLLs failed to lock!")
-              self.log.trace("QPLL(s) reporting locked!")
+                # Check for lock a short time later.
+                time.sleep(0.010)
+                # Clear all QPLL sticky bits
+                self.regs.poke32(self.MGT_QPLL_CONTROL, 0b1 << 16)
+                # Check for lock on active quads only.
+                rb = self.regs.peek32(self.MGT_QPLL_CONTROL)
+                rb_mask = 0x0
+                locked_val = 0x0
+                for nibble in range(qplls):
+                    if (rb & (0xF << nibble*4)) != (0x2 << nibble*4):
+                        self.log.warning("GT QPLL {} failed to lock!".format(nibble))
+                    locked_val = locked_val | 0x2 << nibble*4
+                    rb_mask    = rb_mask    | 0xF << nibble*4
+                if (rb & rb_mask) != locked_val:
+                    raise RuntimeError("One or more GT QPLLs failed to lock!")
+                self.log.trace("QPLL(s) reporting locked!")
 
     def set_drp_target(self, mgt_or_qpll, dev_num):
         """
@@ -327,7 +327,7 @@ class NIMgJESDCore(object):
         assert drp_ch_sel in range(MAX_MGTS + MAX_QPLLs)
         reg_val = (0b1 << drp_ch_sel) | (DRP_ENABLE_VAL << 16)
         self.log.trace("Writing DRP Control Register (offset 0x{:04X}) with 0x{:08X}"
-            .format(self.JESD_MGT_DRP_CONTROL, reg_val))
+                       .format(self.JESD_MGT_DRP_CONTROL, reg_val))
         self.regs.poke32(self.JESD_MGT_DRP_CONTROL, reg_val)
 
     def disable_drp_target(self):
@@ -337,7 +337,7 @@ class NIMgJESDCore(object):
         self.regs.poke32(self.JESD_MGT_DRP_CONTROL, 0x0)
         self.log.trace("DRP accesses disabled!")
 
-    def drp_access(self, rd = True, addr = 0, wr_data = 0):
+    def drp_access(self, rd=True, addr=0, wr_data=0):
         """
         Provides register access to the DRP ports on the MGTs or QPLLs buried inside
         the JESD204b logic. Reads will return the DRP data directly. Writes will return
@@ -353,7 +353,6 @@ class NIMgJESDCore(object):
         core_offset = 0x2800 + (addr << 2)
         if rd:
             rd_data = self.regs.peek32(core_offset)
-            rd_data_valid = rd_data & 0xFFFF
             self.log.trace("Reading DRP register 0x{:04X} at DB Core offset 0x{:04X}... "
                            "0x{:04X}"
                            .format(addr, core_offset, rd_data))
diff --git a/mpm/python/usrp_mpm/cores/tdc_sync.py b/mpm/python/usrp_mpm/cores/tdc_sync.py
index cbed98244..97ee1367c 100644
--- a/mpm/python/usrp_mpm/cores/tdc_sync.py
+++ b/mpm/python/usrp_mpm/cores/tdc_sync.py
@@ -226,9 +226,9 @@ class ClockSynchronizer(object):
         if reset_status != 0x00:
             self.log.error(
                 "TDC Reset Failed to Clear! " \
-                "Check that your clocks are toggling. Status: 0x{:x}".format(
-                    reset_status
-            ))
+                "Check that your clocks are toggling. Status: 0x{:x}"
+                .format(reset_status)
+            )
             raise RuntimeError("TDC Reset Failed.")
         self.log.trace("Enabling the TDC")
         # Enable the TDC.
@@ -459,7 +459,7 @@ class ClockSynchronizer(object):
         return True
 
 
-    def dac_bist(self, taps_from_center = 100):
+    def dac_bist(self, taps_from_center=100):
         """
         A quick BIST of the DAC, proving it is (a) alive and (b) can shift the clock.
 
diff --git a/mpm/python/usrp_mpm/dboard_manager/lmk_mg.py b/mpm/python/usrp_mpm/dboard_manager/lmk_mg.py
index 3cb6ea7c9..e7327ee83 100644
--- a/mpm/python/usrp_mpm/dboard_manager/lmk_mg.py
+++ b/mpm/python/usrp_mpm/dboard_manager/lmk_mg.py
@@ -40,13 +40,13 @@ class LMK04828Mg(LMK04828):
         self.pll2_vco_freq  = (self.vcxo_freq/self.pll2_r_divider)*self.pll2_prescaler*self.pll2_n_divider
         self.log.trace("Variable Configuration Report: "
                        "clkin1_r = 0d{}, clkout_div = 0d{}, pll1_n = 0d{}"
-           .format(self.clkin_r_divider, self.clkout_divider, self.pll1_n_divider))
+                       .format(self.clkin_r_divider, self.clkout_divider, self.pll1_n_divider))
         self.log.trace("Variable Configuration Report: "
                        "sysref_divider = 0d{}, pll2_pre = 0d{}, pll2_n = 0d{}"
-           .format(self.sysref_divider, self.pll2_prescaler, self.pll2_n_divider))
+                       .format(self.sysref_divider, self.pll2_prescaler, self.pll2_n_divider))
         self.log.trace("Variable Configuration Report: "
                        "pll2_vco_freq = 0d{}"
-           .format(self.pll2_vco_freq))
+                       .format(self.pll2_vco_freq))
         # Run .init() and .config() right off the bat. Save clock shifty-ness for later.
         self.init()
         self.config()
@@ -232,7 +232,8 @@ class LMK04828Mg(LMK04828):
         Apply time shift using the dynamic digital delays inside the LMK.
         """
         self.log.trace("Clock Shifting Commencing using Dynamic Digital Delay...")
-        ddly_value = self.divide_to_cnth_cntl_reg(self.clkout_divider+1) if num_shifts >= 0 else self.divide_to_cnth_cntl_reg(self.clkout_divider-1)
+        ddly_value = self.divide_to_cnth_cntl_reg(self.clkout_divider+1) \
+                if num_shifts >= 0 else self.divide_to_cnth_cntl_reg(self.clkout_divider-1)
         ddly_value_sysref = self.sysref_divider+1 if num_shifts >= 0 else self.sysref_divider-1
         self.pokes8((
             (0x141, 0xB1), # Dynamic digital delay enable on outputs 0, 8, 10
@@ -248,7 +249,7 @@ class LMK04828Mg(LMK04828):
             (0x13D, (ddly_value_sysref & 0x00FF) >> 0), # SYSREF DDLY value [7:0]
             (0x144, 0x4E), # Enable SYNC on outputs 0, 8, 10
         ))
-        for x in range(abs(num_shifts)):
+        for _ in range(abs(num_shifts)):
             self.poke8(0x142, 0x1)
         # Put everything back the way it was before shifting.
         self.poke8(0x144, 0xFF) # Disable SYNC on all outputs including SYSREF
diff --git a/mpm/python/usrp_mpm/dboard_manager/magnesium.py b/mpm/python/usrp_mpm/dboard_manager/magnesium.py
index 7d56dea67..0eaf25ae1 100644
--- a/mpm/python/usrp_mpm/dboard_manager/magnesium.py
+++ b/mpm/python/usrp_mpm/dboard_manager/magnesium.py
@@ -933,8 +933,8 @@ class Magnesium(DboardManagerBase):
     def dump_jesd_core(self):
         " Debug method to dump all JESD core regs "
         with open_uio(
-                label="dboard-regs-{}".format(self.slot_idx),
-                read_only=False
+            label="dboard-regs-{}".format(self.slot_idx),
+            read_only=False
         ) as dboard_ctrl_regs:
             for i in range(0x2000, 0x2110, 0x10):
                 print(("0x%04X " % i), end=' ')
@@ -947,8 +947,8 @@ class Magnesium(DboardManagerBase):
         Debug for accessing the DB Core registers via the RPC shell.
         """
         with open_uio(
-                label="dboard-regs-{}".format(self.slot_idx),
-                read_only=False
+            label="dboard-regs-{}".format(self.slot_idx),
+            read_only=False
         ) as dboard_ctrl_regs:
             rd_data = dboard_ctrl_regs.peek32(addr)
             self.log.trace("DB Core Register 0x{:04X} response: 0x{:08X}".format(addr, rd_data))
@@ -959,8 +959,8 @@ class Magnesium(DboardManagerBase):
         Debug for accessing the DB Core registers via the RPC shell.
         """
         with open_uio(
-                label="dboard-regs-{}".format(self.slot_idx),
-                read_only=False
+            label="dboard-regs-{}".format(self.slot_idx),
+            read_only=False
         ) as dboard_ctrl_regs:
             self.log.trace("Writing DB Core Register 0x{:04X} with 0x{:08X}...".format(addr, data))
             dboard_ctrl_regs.poke32(addr, data)
diff --git a/mpm/python/usrp_mpm/discovery.py b/mpm/python/usrp_mpm/discovery.py
index 2efd25b80..3adf98b28 100644
--- a/mpm/python/usrp_mpm/discovery.py
+++ b/mpm/python/usrp_mpm/discovery.py
@@ -81,14 +81,14 @@ def _discovery_process(state, discovery_addr):
                 continue
             if data.strip(b"\0") == b"MPM-DISC":
                 log.debug("Sending discovery response to %s port: %d",
-                         sender[0], sender[1])
+                          sender[0], sender[1])
                 resp_str = create_response_string(state)
                 send_data = resp_str
                 log.trace("Return data: %s", send_data)
                 send_sock.sendto(send_data, sender)
             elif data.strip(b"\0").startswith(b"MPM-ECHO"):
                 log.debug("Received echo request from {sender}"
-                         .format(sender=sender[0]))
+                          .format(sender=sender[0]))
                 send_data = data
                 try:
                     send_sock.sendto(send_data, sender)
diff --git a/mpm/python/usrp_mpm/periph_manager/base.py b/mpm/python/usrp_mpm/periph_manager/base.py
index 6e72950fb..60eaee244 100644
--- a/mpm/python/usrp_mpm/periph_manager/base.py
+++ b/mpm/python/usrp_mpm/periph_manager/base.py
@@ -13,7 +13,6 @@ from hashlib import md5
 from time import sleep
 from concurrent import futures
 from builtins import str
-from builtins import range
 from builtins import object
 from six import iteritems, itervalues
 from usrp_mpm.mpmlog import get_logger
-- 
2.11.0

