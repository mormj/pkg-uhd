From 9ccd93ab11ebf2338b763a86aaf740c710fcc13d Mon Sep 17 00:00:00 2001
From: Michael West <michael.west@ettus.com>
Date: Thu, 20 Feb 2014 11:27:57 -0800
Subject: [PATCH 06/39] Fixed bug found during testing where internal clock
 reference was taking several seconds to lock. Added
 reset to the clock control and called it whenever the
 clock reference is changed.

---
 host/lib/usrp/x300/x300_clock_ctrl.cpp |    4 ++++
 host/lib/usrp/x300/x300_clock_ctrl.hpp |    6 ++++++
 host/lib/usrp/x300/x300_impl.cpp       |   26 +++++++++++++++-----------
 3 files changed, 25 insertions(+), 11 deletions(-)

--- a/host/lib/usrp/x300/x300_clock_ctrl.cpp
+++ b/host/lib/usrp/x300/x300_clock_ctrl.cpp
@@ -48,6 +48,10 @@
     set_master_clock_rate(master_clock_rate);
 }
 
+void reset() {
+    set_master_clock_rate(_master_clock_rate);
+}
+
 void sync_clocks(void) {
     //soft sync:
     //put the sync IO into output mode - FPGA must be input
--- a/host/lib/usrp/x300/x300_clock_ctrl.hpp
+++ b/host/lib/usrp/x300/x300_clock_ctrl.hpp
@@ -78,6 +78,12 @@
      * \param true = on, false = off
      */
     virtual void set_ref_out(const bool) = 0;
+
+    /*! Reset the clock control.
+     *  Should be called if the reference clock changes
+     *  to reduce the time required to achieve a lock.
+     */
+    virtual void reset(void) = 0;
 };
 
 #endif /* INCLUDED_X300_CLOCK_CTRL_HPP */
--- a/host/lib/usrp/x300/x300_impl.cpp
+++ b/host/lib/usrp/x300/x300_impl.cpp
@@ -579,15 +579,6 @@
     ////////////////////////////////////////////////////////////////////
     UHD_MSG(status) << "Setup RF frontend clocking..." << std::endl;
 
-    // Init shadow and clock source; the device comes up with it's internal
-    // clock source before locking to something else (if requested).
-    mb.clock_control_regs__clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_INTERNAL;
-    mb.clock_control_regs__pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_INTERNAL;
-    mb.clock_control_regs__pps_out_enb = 0;
-    mb.clock_control_regs__tcxo_enb = 1;
-    mb.clock_control_regs__gpsdo_pwr = 1;
-    this->update_clock_control(mb);
-
     size_t hw_rev = 0;
     if(mb_eeprom.has_key("revision") and not mb_eeprom["revision"].empty()) {
         try {
@@ -604,6 +595,15 @@
         hw_rev = X300_REV("D");
     }
 
+    //Initialize clock control with internal references and GPSDO power on.
+    mb.clock_control_regs__clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_INTERNAL;
+    mb.clock_control_regs__pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_INTERNAL;
+    mb.clock_control_regs__pps_out_enb = 0;
+    mb.clock_control_regs__tcxo_enb = 1;
+    mb.clock_control_regs__gpsdo_pwr = 1;
+    this->update_clock_control(mb);
+
+    //Create clock control
     mb.clock = x300_clock_ctrl::make(mb.zpu_spi,
         1 /*slaveno*/,
         hw_rev,
@@ -782,13 +782,13 @@
             UHD_MSG(status) << "Initializing time to the GPSDO time" << std::endl;
             const time_t tp = time_t(mb.gps->get_sensor("gps_time").to_int()+1);
             _tree->access<time_spec_t>(mb_path / "time" / "pps").set(time_spec_t(tp));
+            boost::this_thread::sleep(boost::posix_time::seconds(1));   //wait for time to be set
         } else {
             _tree->access<std::string>(mb_path / "clock_source" / "value").set("internal");
             _tree->access<std::string>(mb_path / "time_source" / "value").set("internal");
             UHD_MSG(status) << "References initialized to internal sources" << std::endl;
         }
     }
-
 }
 
 x300_impl::~x300_impl(void)
@@ -1316,7 +1316,11 @@
 
     this->update_clock_control(mb);
 
-    //check for lock - poll every 10 ms for up to 1 second
+    //reset the clock control
+    //without this, the lock time is multiple seconds and the poll below will fail
+    mb.clock->reset();
+
+    //check for lock - poll every 100 ms for up to 1 second
     for (int i = 0; i < 10; i++)
     {
         boost::this_thread::sleep(boost::posix_time::milliseconds(100));
