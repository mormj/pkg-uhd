From 8e5fe11b6015c3456261d7b7b2ef6918fefa1ee8 Mon Sep 17 00:00:00 2001
From: Ashish Chaudhari <ashish@ettus.com>
Date: Thu, 24 Apr 2014 13:01:37 -0700
Subject: [PATCH 06/31] x300: Cleanup for PCIe flushing

---
 host/lib/transport/nirio/niusrprio_session.cpp |   28 ++++++------
 host/lib/transport/nirio_zero_copy.cpp         |   54 +++++++++++++-----------
 2 files changed, 44 insertions(+), 38 deletions(-)

diff --git a/host/lib/transport/nirio/niusrprio_session.cpp b/host/lib/transport/nirio/niusrprio_session.cpp
index dd9cc2f..094009a 100644
--- a/host/lib/transport/nirio/niusrprio_session.cpp
+++ b/host/lib/transport/nirio/niusrprio_session.cpp
@@ -233,22 +233,22 @@ nirio_status niusrprio_session::_ensure_fpga_ready()
 
         //Disable all FIFOs in the kernel driver
         _riok_proxy.stop_all_fifos();
-    }
 
-    boost::posix_time::ptime start_time = boost::posix_time::microsec_clock::local_time();
-    boost::posix_time::time_duration elapsed;
-    do {
-        boost::this_thread::sleep(boost::posix_time::microsec(1000)); //Avoid flooding the bus
-        elapsed = boost::posix_time::microsec_clock::local_time() - start_time;
-        nirio_status_chain(_riok_proxy.peek(FPGA_STATUS_REG, reg_data), status);
-    } while (
-        nirio_status_not_fatal(status) &&
-        (reg_data & FPGA_STATUS_DMA_ACTIVE_MASK) &&
-        elapsed.total_milliseconds() < FPGA_READY_TIMEOUT_IN_MS);
+        boost::posix_time::ptime start_time = boost::posix_time::microsec_clock::local_time();
+        boost::posix_time::time_duration elapsed;
+        do {
+            boost::this_thread::sleep(boost::posix_time::milliseconds(10)); //Avoid flooding the bus
+            elapsed = boost::posix_time::microsec_clock::local_time() - start_time;
+            nirio_status_chain(_riok_proxy.peek(FPGA_STATUS_REG, reg_data), status);
+        } while (
+            nirio_status_not_fatal(status) &&
+            (reg_data & FPGA_STATUS_DMA_ACTIVE_MASK) &&
+            elapsed.total_milliseconds() < FPGA_READY_TIMEOUT_IN_MS);
 
-    nirio_status_chain(_riok_proxy.peek(FPGA_STATUS_REG, reg_data), status);
-    if (nirio_status_not_fatal(status) && (reg_data & FPGA_STATUS_DMA_ACTIVE_MASK)) {
-        return NiRio_Status_FpgaBusy;
+        nirio_status_chain(_riok_proxy.peek(FPGA_STATUS_REG, reg_data), status);
+        if (nirio_status_not_fatal(status) && (reg_data & FPGA_STATUS_DMA_ACTIVE_MASK)) {
+            return NiRio_Status_FifoReserved;
+        }
     }
 
     return status;
diff --git a/host/lib/transport/nirio_zero_copy.cpp b/host/lib/transport/nirio_zero_copy.cpp
index 87739b9..a739c01 100644
--- a/host/lib/transport/nirio_zero_copy.cpp
+++ b/host/lib/transport/nirio_zero_copy.cpp
@@ -292,34 +292,40 @@ private:
         static const uint32_t TIMEOUT_IN_MS = 100;
 
         uint32_t reg_data = 0xffffffff;
+        bool tx_busy = true, rx_busy = true;
         boost::posix_time::ptime start_time;
         boost::posix_time::time_duration elapsed;
         nirio_status status = NiRio_Status_Success;
 
-        start_time = boost::posix_time::microsec_clock::local_time();
-        do {
-            boost::this_thread::sleep(boost::posix_time::microsec(50)); //Avoid flooding the bus
-            elapsed = boost::posix_time::microsec_clock::local_time() - start_time;
-            nirio_status_chain(_proxy().peek(
-                PCIE_TX_DMA_REG(DMA_CTRL_STATUS_REG, _fifo_instance), reg_data), status);
-        } while (
-            nirio_status_not_fatal(status) &&
-            (reg_data & DMA_STATUS_BUSY) &&
-            elapsed.total_milliseconds() < TIMEOUT_IN_MS);
-
-        start_time = boost::posix_time::microsec_clock::local_time();
-        do {
-            boost::this_thread::sleep(boost::posix_time::microsec(50)); //Avoid flooding the bus
-            elapsed = boost::posix_time::microsec_clock::local_time() - start_time;
-            nirio_status_chain(_proxy().peek(
-                PCIE_RX_DMA_REG(DMA_CTRL_STATUS_REG, _fifo_instance), reg_data), status);
-        } while (
-            nirio_status_not_fatal(status) &&
-            (reg_data & DMA_STATUS_BUSY) &&
-            elapsed.total_milliseconds() < TIMEOUT_IN_MS);
-
-        nirio_status_to_exception(status,
-            "Could not create nirio_zero_copy transport because the FPGA is busy. Try re-downloading the LVBITX.");
+        nirio_status_chain(_proxy().peek(
+            PCIE_TX_DMA_REG(DMA_CTRL_STATUS_REG, _fifo_instance), reg_data), status);
+        tx_busy = (reg_data & DMA_STATUS_BUSY);
+        nirio_status_chain(_proxy().peek(
+            PCIE_RX_DMA_REG(DMA_CTRL_STATUS_REG, _fifo_instance), reg_data), status);
+        rx_busy = (reg_data & DMA_STATUS_BUSY);
+
+        if (nirio_status_not_fatal(status) && !tx_busy && !rx_busy) {
+            start_time = boost::posix_time::microsec_clock::local_time();
+            do {
+                boost::this_thread::sleep(boost::posix_time::microsec(50)); //Avoid flooding the bus
+                elapsed = boost::posix_time::microsec_clock::local_time() - start_time;
+                nirio_status_chain(_proxy().peek(
+                    PCIE_TX_DMA_REG(DMA_CTRL_STATUS_REG, _fifo_instance), reg_data), status);
+                tx_busy = (reg_data & DMA_STATUS_BUSY);
+                nirio_status_chain(_proxy().peek(
+                    PCIE_RX_DMA_REG(DMA_CTRL_STATUS_REG, _fifo_instance), reg_data), status);
+                rx_busy = (reg_data & DMA_STATUS_BUSY);
+            } while (
+                nirio_status_not_fatal(status) &&
+                (tx_busy || rx_busy) &&
+                elapsed.total_milliseconds() < TIMEOUT_IN_MS);
+
+            if (tx_busy || rx_busy) {
+                nirio_status_chain(NiRio_Status_FpgaBusy, status);
+            }
+
+            nirio_status_to_exception(status, "Could not create nirio_zero_copy transport.");
+        }
     }
 
     //memory management -> buffers and fifos
-- 
1.7.10.4

