From 2f1d2af82c0283edbd7faf3b654afcec7377ebda Mon Sep 17 00:00:00 2001
From: michael-west <michael.west@ettus.com>
Date: Mon, 15 Aug 2016 11:26:02 -0700
Subject: [PATCH 09/30] Octoclock: Simplify GPSDO UART so it does not strip or
 add characters

---
 host/lib/usrp_clock/octoclock/octoclock_uart.cpp | 24 ++++++++++--------------
 1 file changed, 10 insertions(+), 14 deletions(-)

diff --git a/host/lib/usrp_clock/octoclock/octoclock_uart.cpp b/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
index 538ee06..0b5b840 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
@@ -68,13 +68,12 @@ namespace uhd{
     }
 
     void octoclock_uart_iface::write_uart(const std::string &buf){
-        std::string to_send = boost::algorithm::replace_all_copy(buf, "\n", "\r\n");
         size_t len = 0;
 
         octoclock_packet_t pkt_out;
         pkt_out.sequence = uhd::htonx<boost::uint32_t>(++_sequence);
-        pkt_out.len = to_send.size();
-        memcpy(pkt_out.data, to_send.c_str(), to_send.size());
+        pkt_out.len = buf.size();
+        memcpy(pkt_out.data, buf.c_str(), buf.size());
 
         boost::uint8_t octoclock_data[udp_simple::mtu];
         const octoclock_packet_t *pkt_in = reinterpret_cast<octoclock_packet_t*>(octoclock_data);
@@ -87,29 +86,26 @@ namespace uhd{
 
     std::string octoclock_uart_iface::read_uart(double timeout){
         std::string result;
-        bool first_time = true;
         boost::system_time exit_time = boost::get_system_time() + boost::posix_time::milliseconds(long(timeout*1e3));
 
-        while(boost::get_system_time() < exit_time){
-            if (first_time)
-                first_time = false;
-            else
-                boost::this_thread::sleep(boost::posix_time::milliseconds(1));
-
+        while(true)
+        {
             _update_cache();
 
             for(char ch = _getchar(); ch != 0; ch = _getchar()){
-                if(ch == '\r') continue; //Skip carriage returns
-                if(ch == '\n' and _rxbuff.empty()) continue; //Skip empty lines
                 _rxbuff += ch;
 
                 //If newline found, return string
                 if(ch == '\n'){
-                    result = _rxbuff;
-                    _rxbuff.clear();
+                    result.swap(_rxbuff);
                     return result;
                 }
             }
+            if (boost::get_system_time() > exit_time)
+            {
+                break;
+            }
+            boost::this_thread::sleep(boost::posix_time::milliseconds(1));
         }
 
         return result;
-- 
2.1.4

