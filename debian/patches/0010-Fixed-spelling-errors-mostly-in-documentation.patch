From b25c127e453219b58883831d364b65ae6740ccb7 Mon Sep 17 00:00:00 2001
From: Derek Kozel <derek.kozel@ettus.com>
Date: Tue, 5 Apr 2016 16:50:08 -0700
Subject: [PATCH 10/12] Fixed spelling errors, mostly in documentation

---
 host/docs/install.dox                           |  2 +-
 host/docs/usrp_b200.dox                         |  2 +-
 host/include/uhd/device_deprecated.ipp          |  2 +-
 host/include/uhd/exception.hpp                  |  4 ++--
 host/include/uhd/image_loader.hpp               |  2 +-
 host/include/uhd/stream.hpp                     |  2 +-
 host/include/uhd/transport/bounded_buffer.hpp   |  2 +-
 host/include/uhd/transport/nirio/nirio_fifo.ipp |  2 +-
 host/include/uhd/transport/udp_zero_copy.hpp    |  2 +-
 host/include/uhd/transport/usb_control.hpp      |  2 +-
 host/include/uhd/transport/usb_zero_copy.hpp    | 16 ++++++++--------
 host/include/uhd/types/sid.hpp                  |  2 +-
 host/include/uhd/types/tune_request.hpp         |  2 +-
 host/include/uhd/usrp/dboard_iface.hpp          |  4 ++--
 host/include/uhd/usrp/multi_usrp.hpp            |  2 +-
 host/include/uhd/usrp/usrp.h                    |  4 ++--
 host/include/uhd/utils/gain_group.hpp           |  4 ++--
 host/include/uhd/utils/thread_priority.h        |  2 +-
 host/include/uhd/utils/thread_priority.hpp      |  2 +-
 19 files changed, 30 insertions(+), 30 deletions(-)

diff --git a/host/docs/install.dox b/host/docs/install.dox
index fc029b3..a6c96b2 100644
--- a/host/docs/install.dox
+++ b/host/docs/install.dox
@@ -101,7 +101,7 @@ This is an automated way of installing UHD from source. See also \ref build_pybo
 
 We recommend using MacPorts and actively support UHD development on OS X via this method.
 Using MacPorts, the correct hardware device images are automatically installed for you,
-and there are no post install tasks. WIth a single command, you can be up and running in short order.
+and there are no post install tasks. With a single command, you can be up and running in short order.
 
 If you do not already have MacPorts installed, you will need to install it first. Make sure to follow the MacPorts shell environment changes needed such that MacPorts installed executables are found before all others. These are the only changes to the shell environment needed to execute any MacPorts-installed executable. Setting any DYLD environment variable (e.g., DYLD_LIBRARY_PATH) for general use is highly discouraged, because doing so, in our experience, leads to problems down the road that are very difficult to diagnose. OSX provides robust means for correcting DYLD-based issues even after dependencies are installed.
 
diff --git a/host/docs/usrp_b200.dox b/host/docs/usrp_b200.dox
index be63b8f..248f07e 100644
--- a/host/docs/usrp_b200.dox
+++ b/host/docs/usrp_b200.dox
@@ -185,7 +185,7 @@ Below is a table of the B200mini LED indicators and their meanings:
   </tr>
 </table>
 
-TX LED indicators are on when transimitting data and off when no samples are
+TX LED indicators are on when transmitting data and off when no samples are
 available to transmit.  RX LED indicators are on when sending samples to the
 host and off when unable to do so.  This means that TX/RX activity LED
 indicators will blink off in a temporary transmit underflow or receive overflow
diff --git a/host/include/uhd/device_deprecated.ipp b/host/include/uhd/device_deprecated.ipp
index 58c43a8..2741df4 100644
--- a/host/include/uhd/device_deprecated.ipp
+++ b/host/include/uhd/device_deprecated.ipp
@@ -106,7 +106,7 @@ size_t send(
  * will hold a pointer into the remaining portion of the packet.
  * Subsequent calls will load from the remainder of the packet,
  * and will flag the metadata to show that this is a fragment.
- * The next call to receive, after the remainder becomes exahausted,
+ * The next call to receive, after the remainder becomes exhausted,
  * will perform an over-the-wire receive as usual.
  * See the rx metadata fragment flags and offset fields for details.
  *
diff --git a/host/include/uhd/exception.hpp b/host/include/uhd/exception.hpp
index a211061..7eddf5f 100644
--- a/host/include/uhd/exception.hpp
+++ b/host/include/uhd/exception.hpp
@@ -142,9 +142,9 @@ namespace uhd{
     };
 
     /*!
-     * Create a formated string with throw-site information.
+     * Create a formatted string with throw-site information.
      * Fills in the function name, file name, and line number.
-     * \param what the std::exeption message
+     * \param what the std::exception message
      * \return the formatted exception message
      */
     #define UHD_THROW_SITE_INFO(what) std::string( \
diff --git a/host/include/uhd/image_loader.hpp b/host/include/uhd/image_loader.hpp
index 5963c86..fd4a967 100644
--- a/host/include/uhd/image_loader.hpp
+++ b/host/include/uhd/image_loader.hpp
@@ -80,7 +80,7 @@ public:
      * These instructions should be queried if the user interrupts an image loading
      * session, as this will likely leave the device in an unstable state.
      * \param device_type the "type=foo" value given in an --args option
-     * \return recoverying instructions
+     * \return recovery instructions
      */
     static std::string get_recovery_instructions(const std::string &device_type);
 };
diff --git a/host/include/uhd/stream.hpp b/host/include/uhd/stream.hpp
index ccf961a..e8f9b7b 100644
--- a/host/include/uhd/stream.hpp
+++ b/host/include/uhd/stream.hpp
@@ -204,7 +204,7 @@ public:
      * will hold a pointer into the remaining portion of the packet.
      * Subsequent calls will load from the remainder of the packet,
      * and will flag the metadata to show that this is a fragment.
-     * The next call to receive, after the remainder becomes exahausted,
+     * The next call to receive, after the remainder becomes exhausted,
      * will perform an over-the-wire receive as usual.
      * See the rx metadata fragment flags and offset fields for details.
      *
diff --git a/host/include/uhd/transport/bounded_buffer.hpp b/host/include/uhd/transport/bounded_buffer.hpp
index 620a708..156ad4f 100644
--- a/host/include/uhd/transport/bounded_buffer.hpp
+++ b/host/include/uhd/transport/bounded_buffer.hpp
@@ -55,7 +55,7 @@ namespace uhd{ namespace transport{
         /*!
          * Push a new element into the bounded buffer.
          * If the buffer is full prior to the push,
-         * make room by poping the oldest element.
+         * make room by popping the oldest element.
          * \param elem the new element to push
          * \return true if the element fit without popping for space
          */
diff --git a/host/include/uhd/transport/nirio/nirio_fifo.ipp b/host/include/uhd/transport/nirio/nirio_fifo.ipp
index 72a337a..a7e2bb2 100644
--- a/host/include/uhd/transport/nirio/nirio_fifo.ipp
+++ b/host/include/uhd/transport/nirio/nirio_fifo.ipp
@@ -310,7 +310,7 @@ nirio_status nirio_fifo<data_t>::_ensure_transfer_completed(uint32_t timeout_ms)
     nirio_status_chain(_get_transfer_count(actual_xfer_count), status);
 
     //We count the elapsed time using a simple counter instead of the high
-    //resolution timebase for efficieny reasons. The call to fetch the time
+    //resolution timebase for efficiency reasons. The call to fetch the time
     //requires a user-kernel transition which has a large overhead compared
     //to a simple mem read. As a tradeoff, we deal with a less precise timeout.
     size_t approx_us_elapsed = 0;
diff --git a/host/include/uhd/transport/udp_zero_copy.hpp b/host/include/uhd/transport/udp_zero_copy.hpp
index de4721b..dcf0204 100644
--- a/host/include/uhd/transport/udp_zero_copy.hpp
+++ b/host/include/uhd/transport/udp_zero_copy.hpp
@@ -31,7 +31,7 @@ namespace uhd{ namespace transport{
  * Rather, the zero copy transport gives the caller memory references.
  * The caller informs the transport when it is finished with the reference.
  *
- * On linux systems, the zero copy transport can use a kernel packet ring.
+ * On Linux systems, the zero copy transport can use a kernel packet ring.
  * If no platform specific solution is available, make returns a boost asio
  * implementation that wraps the functionality around a standard send/recv calls.
  */
diff --git a/host/include/uhd/transport/usb_control.hpp b/host/include/uhd/transport/usb_control.hpp
index 624e537..23f35d7 100644
--- a/host/include/uhd/transport/usb_control.hpp
+++ b/host/include/uhd/transport/usb_control.hpp
@@ -29,7 +29,7 @@ public:
     virtual ~usb_control(void) = 0;
 
     /*!
-     * Create a new usb control transport:
+     * Create a new USB control transport:
      * This transport is for sending and receiving control information from
      * the host to device using the Default Control Pipe.
      *
diff --git a/host/include/uhd/transport/usb_zero_copy.hpp b/host/include/uhd/transport/usb_zero_copy.hpp
index 3990568..ae1926e 100644
--- a/host/include/uhd/transport/usb_zero_copy.hpp
+++ b/host/include/uhd/transport/usb_zero_copy.hpp
@@ -25,12 +25,12 @@
 namespace uhd { namespace transport {
 
 /*!
- * A zero copy usb transport provides an efficient way to handle data.
+ * A zero copy USB transport provides an efficient way to handle data.
  * by avoiding the extra copy when recv() or send() is called on the handle.
  * Rather, the zero copy transport gives the caller memory references.
  * The caller informs the transport when it is finished with the reference.
  *
- * On linux systems, the zero copy transport can use a kernel packet ring.
+ * On Linux systems, the zero copy transport can use a kernel packet ring.
  * If no platform specific solution is available, make returns a boost asio
  * implementation that wraps functionality around standard send/recv calls.
  */
@@ -39,19 +39,19 @@ public:
     typedef boost::shared_ptr<usb_zero_copy> sptr;
 
     /*!
-     * Make a new zero copy usb transport:
+     * Make a new zero copy USB transport:
      * This transport is for sending and receiving between the host
      * and a pair of USB bulk transfer endpoints.
      * The primary usage for this transport is data transactions.
      * The underlying implementation may be platform specific.
      *
      * \param handle a device handle that uniquely identifying the device
-     * \param recv_interface an integer specifiying an IN interface number
-     * \param recv_endpoint an integer specifiying an IN endpoint number
-     * \param send_interface an integer specifiying an OUT interface number
-     * \param send_endpoint an integer specifiying an OUT endpoint number
+     * \param recv_interface an integer specifying an IN interface number
+     * \param recv_endpoint an integer specifying an IN endpoint number
+     * \param send_interface an integer specifying an OUT interface number
+     * \param send_endpoint an integer specifying an OUT endpoint number
      * \param hints optional parameters to pass to the underlying transport
-     * \return a new zero copy usb object
+     * \return a new zero copy USB object
      */
     static sptr make(
         usb_device_handle::sptr handle,
diff --git a/host/include/uhd/types/sid.hpp b/host/include/uhd/types/sid.hpp
index 95034c7..9ac68f7 100644
--- a/host/include/uhd/types/sid.hpp
+++ b/host/include/uhd/types/sid.hpp
@@ -28,7 +28,7 @@ namespace uhd {
      * \brief Represents a stream ID (SID).
      *
      * A stream ID (SID) is an identifier for data.
-     * It is a 32-Bit value which consistst of 16 Bits
+     * It is a 32-Bit value which consists of 16 Bits
      * for the source address and 16 Bits for the destination
      * address.
      * Every address is split into two parts: The _address_, which
diff --git a/host/include/uhd/types/tune_request.hpp b/host/include/uhd/types/tune_request.hpp
index d1f3b44..d9608f9 100644
--- a/host/include/uhd/types/tune_request.hpp
+++ b/host/include/uhd/types/tune_request.hpp
@@ -94,7 +94,7 @@ namespace uhd{
          * Possible keys used by args (depends on implementation):
          *
          * - mode_n: Allows the user to tell the daughterboard tune code
-         * to choose between an integer N diviver or fractional N divider.
+         * to choose between an integer N divider or fractional N divider.
          * Default is fractional N on boards that support fractional N tuning.
          * Fractional N provides greater tuning accuracy at the expense of spurs.
          * Possible options for this key: "integer" or "fractional".
diff --git a/host/include/uhd/usrp/dboard_iface.hpp b/host/include/uhd/usrp/dboard_iface.hpp
index f8f318a..686deb4 100644
--- a/host/include/uhd/usrp/dboard_iface.hpp
+++ b/host/include/uhd/usrp/dboard_iface.hpp
@@ -41,10 +41,10 @@ struct UHD_API dboard_iface_special_props_t{
 
     /*!
      * Mangle i2c addresses:
-     * When i2c is shared across multiple daugterboard slots,
+     * When i2c is shared across multiple daughterboard slots,
      * the i2c addresses will be mangled on the secondary slot
      * to avoid conflicts between slots in the i2c address space.
-     * The mangling is daguhterboard specific so the implementation
+     * The mangling is daughterboard specific so the implementation
      * needs to know whether it should use mangled addresses or not.
      */
     bool mangle_i2c_addrs;
diff --git a/host/include/uhd/usrp/multi_usrp.hpp b/host/include/uhd/usrp/multi_usrp.hpp
index cc39254..715a572 100644
--- a/host/include/uhd/usrp/multi_usrp.hpp
+++ b/host/include/uhd/usrp/multi_usrp.hpp
@@ -199,7 +199,7 @@ public:
     virtual time_spec_t get_time_now(size_t mboard = 0) = 0;
 
     /*!
-     * Get the time when the last pps pulse occured.
+     * Get the time when the last pps pulse occurred.
      * \param mboard which motherboard to query
      * \return a timespec representing the last pps
      */
diff --git a/host/include/uhd/usrp/usrp.h b/host/include/uhd/usrp/usrp.h
index 67f8e0f..651279e 100644
--- a/host/include/uhd/usrp/usrp.h
+++ b/host/include/uhd/usrp/usrp.h
@@ -652,7 +652,7 @@ UHD_API uhd_error uhd_usrp_set_rx_subdev_spec(
     size_t mboard
 );
 
-//! Get the RX frontend specfication for the given device
+//! Get the RX frontend specification for the given device
 UHD_API uhd_error uhd_usrp_get_rx_subdev_spec(
     uhd_usrp_handle h,
     size_t mboard,
@@ -876,7 +876,7 @@ UHD_API uhd_error uhd_usrp_set_tx_subdev_spec(
     size_t mboard
 );
 
-//! Get the TX frontend specfication for the given device
+//! Get the TX frontend specification for the given device
 UHD_API uhd_error uhd_usrp_get_tx_subdev_spec(
     uhd_usrp_handle h,
     size_t mboard,
diff --git a/host/include/uhd/utils/gain_group.hpp b/host/include/uhd/utils/gain_group.hpp
index 56acce0..9cac1f5 100644
--- a/host/include/uhd/utils/gain_group.hpp
+++ b/host/include/uhd/utils/gain_group.hpp
@@ -65,7 +65,7 @@ public:
      * For an empty name, set the overall gain value for this group.
      * The power will be distributed across individual gain elements.
      * The semantics of how to do this are determined by the priority.
-     * \param gain the gain to set for the lement or across the group
+     * \param gain the gain to set for the element or across the group
      * \param name name of the gain element (optional)
      */
     virtual void set_value(double gain, const std::string &name = "") = 0;
@@ -81,7 +81,7 @@ public:
      * Register a set of gain functions into this group:
      *
      * The name should be a unique and non-empty name.
-     * Othwerwise, the implementation will rename it.
+     * Otherwise, the implementation will rename it.
      *
      * Priority determines how power will be distributed
      * with higher priorities getting the power first,
diff --git a/host/include/uhd/utils/thread_priority.h b/host/include/uhd/utils/thread_priority.h
index 217d7a1..139af26 100644
--- a/host/include/uhd/utils/thread_priority.h
+++ b/host/include/uhd/utils/thread_priority.h
@@ -31,7 +31,7 @@ static const float uhd_default_thread_priority = 0.5;
  * Set the scheduling priority on the current thread.
  *
  * A new thread or calling process should make this call
- * with the defailts this to enable realtime scheduling.
+ * with the defaults this to enable realtime scheduling.
  *
  * A priority of zero corresponds to normal priority.
  * Positive priority values are higher than normal.
diff --git a/host/include/uhd/utils/thread_priority.hpp b/host/include/uhd/utils/thread_priority.hpp
index 988fc30..c34ac55 100644
--- a/host/include/uhd/utils/thread_priority.hpp
+++ b/host/include/uhd/utils/thread_priority.hpp
@@ -28,7 +28,7 @@ namespace uhd{
      * Set the scheduling priority on the current thread.
      *
      * A new thread or calling process should make this call
-     * with the defailts this to enable realtime scheduling.
+     * with the defaults this to enable realtime scheduling.
      *
      * A priority of zero corresponds to normal priority.
      * Positive priority values are higher than normal.
-- 
2.1.4

