From 9126069560de0a462f58596055dad15b35693dce Mon Sep 17 00:00:00 2001
From: michael-west <michael.west@ettus.com>
Date: Sat, 15 Mar 2014 08:42:05 -0700
Subject: [PATCH 26/39] Addressed comments from review. - Fixed typos. -
 Renamed reset() to reset_clocks(). - Created
 wait_for_ref_locked() function.

---
 host/lib/usrp/x300/x300_clock_ctrl.cpp |    2 +-
 host/lib/usrp/x300/x300_clock_ctrl.hpp |    4 +-
 host/lib/usrp/x300/x300_impl.cpp       |   76 ++++++++++++++++++--------------
 host/lib/usrp/x300/x300_impl.hpp       |   11 ++---
 4 files changed, 53 insertions(+), 40 deletions(-)

--- a/host/lib/usrp/x300/x300_clock_ctrl.cpp
+++ b/host/lib/usrp/x300/x300_clock_ctrl.cpp
@@ -48,7 +48,7 @@
     set_master_clock_rate(master_clock_rate);
 }
 
-void reset() {
+void reset_clocks() {
     set_master_clock_rate(_master_clock_rate);
 }
 
--- a/host/lib/usrp/x300/x300_clock_ctrl.hpp
+++ b/host/lib/usrp/x300/x300_clock_ctrl.hpp
@@ -79,11 +79,11 @@
      */
     virtual void set_ref_out(const bool) = 0;
 
-    /*! Reset the clock control.
+    /*! Reset the clocks.
      *  Should be called if the reference clock changes
      *  to reduce the time required to achieve a lock.
      */
-    virtual void reset(void) = 0;
+    virtual void reset_clocks(void) = 0;
 };
 
 #endif /* INCLUDED_X300_CLOCK_CTRL_HPP */
--- a/host/lib/usrp/x300/x300_impl.cpp
+++ b/host/lib/usrp/x300/x300_impl.cpp
@@ -596,11 +596,11 @@
     }
 
     //Initialize clock control with internal references and GPSDO power on.
-    mb.clock_control_regs__clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_INTERNAL;
-    mb.clock_control_regs__pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_INTERNAL;
-    mb.clock_control_regs__pps_out_enb = 0;
-    mb.clock_control_regs__tcxo_enb = 1;
-    mb.clock_control_regs__gpsdo_pwr = 1;
+    mb.clock_control_regs_clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_INTERNAL;
+    mb.clock_control_regs_pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_INTERNAL;
+    mb.clock_control_regs_pps_out_enb = 0;
+    mb.clock_control_regs_tcxo_enb = 1;
+    mb.clock_control_regs_gpsdo_pwr = 1;
     this->update_clock_control(mb);
 
     //Create clock control
@@ -611,8 +611,7 @@
         dev_addr.cast<double>("system_ref_rate", X300_DEFAULT_SYSREF_RATE));
 
     //wait for reference clock to lock
-    while (not get_ref_locked(mb.zpu_ctrl).to_bool())
-        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
+    wait_for_ref_locked(mb.zpu_ctrl, 1.0);
 
     ////////////////////////////////////////////////////////////////////
     // create clock properties
@@ -1291,32 +1290,32 @@
 
 void x300_impl::set_time_source_out(mboard_members_t &mb, const bool enb)
 {
-    mb.clock_control_regs__pps_out_enb = enb? 1 : 0;
+    mb.clock_control_regs_pps_out_enb = enb? 1 : 0;
     this->update_clock_control(mb);
 }
 
 void x300_impl::update_clock_control(mboard_members_t &mb)
 {
-    const size_t reg = mb.clock_control_regs__clock_source
-        | (mb.clock_control_regs__pps_select << 2)
-        | (mb.clock_control_regs__pps_out_enb << 4)
-        | (mb.clock_control_regs__tcxo_enb << 5)
-        | (mb.clock_control_regs__gpsdo_pwr << 6)
+    const size_t reg = mb.clock_control_regs_clock_source
+        | (mb.clock_control_regs_pps_select << 2)
+        | (mb.clock_control_regs_pps_out_enb << 4)
+        | (mb.clock_control_regs_tcxo_enb << 5)
+        | (mb.clock_control_regs_gpsdo_pwr << 6)
     ;
     mb.zpu_ctrl->poke32(SR_ADDR(SET0_BASE, ZPU_SR_CLOCK_CTRL), reg);
 }
 
 void x300_impl::update_clock_source(mboard_members_t &mb, const std::string &source)
 {
-    mb.clock_control_regs__clock_source = 0;
-    mb.clock_control_regs__tcxo_enb = 0;
+    mb.clock_control_regs_clock_source = 0;
+    mb.clock_control_regs_tcxo_enb = 0;
     if (source == "internal") {
-        mb.clock_control_regs__clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_INTERNAL;
-        mb.clock_control_regs__tcxo_enb = 1;
+        mb.clock_control_regs_clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_INTERNAL;
+        mb.clock_control_regs_tcxo_enb = 1;
     } else if (source == "external") {
-        mb.clock_control_regs__clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_EXTERNAL;
+        mb.clock_control_regs_clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_EXTERNAL;
     } else if (source == "gpsdo") {
-        mb.clock_control_regs__clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_GPSDO;
+        mb.clock_control_regs_clock_source = ZPU_SR_CLOCK_CTRL_CLK_SRC_GPSDO;
     } else {
         throw uhd::key_error("update_clock_source: unknown source: " + source);
     }
@@ -1325,28 +1324,27 @@
 
     //reset the clock control
     //without this, the lock time is multiple seconds and the poll below will fail
-    mb.clock->reset();
+    mb.clock->reset_clocks();
 
-    //check for lock - poll every 100 ms for up to 1 second
-    for (int i = 0; i < 10; i++)
-    {
-        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
-        if (get_ref_locked(mb.zpu_ctrl).to_bool())
-            return;
+    //wait for lock
+    try {
+        wait_for_ref_locked(mb.zpu_ctrl, 1.0);
+    } catch (uhd::runtime_error &e) {
+        //failed to lock on reference
+        throw uhd::runtime_error(
+            (boost::format("Error setting the clock source to %s: %s  Please check the clock and try again.")
+            % source % e.what()).str());
     }
-
-    //failed to lock on reference
-    throw uhd::runtime_error((boost::format("The %d reference clock failed to lock.  Please check the clock and try again.") % source).str());
 }
 
 void x300_impl::update_time_source(mboard_members_t &mb, const std::string &source)
 {
     if (source == "internal") {
-        mb.clock_control_regs__pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_INTERNAL;
+        mb.clock_control_regs_pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_INTERNAL;
     } else if (source == "external") {
-        mb.clock_control_regs__pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_EXTERNAL;
+        mb.clock_control_regs_pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_EXTERNAL;
     } else if (source == "gpsdo") {
-        mb.clock_control_regs__pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_GPSDO;
+        mb.clock_control_regs_pps_select = ZPU_SR_CLOCK_CTRL_PPS_SRC_GPSDO;
     } else {
         throw uhd::key_error("update_time_source: unknown source: " + source);
     }
@@ -1360,6 +1358,20 @@
     }
 }
 
+void x300_impl::wait_for_ref_locked(wb_iface::sptr ctrl, double timeout)
+{
+    boost::system_time timeout_time = boost::get_system_time() + boost::posix_time::milliseconds(timeout * 1000.0);
+    do
+    {
+        if (get_ref_locked(ctrl).to_bool())
+            return;
+        boost::this_thread::sleep(boost::posix_time::milliseconds(1));
+    } while (boost::get_system_time() < timeout_time);
+
+    //failed to lock on reference
+    throw uhd::runtime_error("The reference clock failed to lock.");
+}
+
 sensor_value_t x300_impl::get_ref_locked(wb_iface::sptr ctrl)
 {
     uint32_t clk_status = ctrl->peek32(SR_ADDR(SET0_BASE, ZPU_RB_CLK_STATUS));
--- a/host/lib/usrp/x300/x300_impl.hpp
+++ b/host/lib/usrp/x300/x300_impl.hpp
@@ -200,11 +200,11 @@
         gpio_core_200::sptr fp_gpio;
 
         //clock control register bits
-        int clock_control_regs__clock_source;
-        int clock_control_regs__pps_select;
-        int clock_control_regs__pps_out_enb;
-        int clock_control_regs__tcxo_enb;
-        int clock_control_regs__gpsdo_pwr;
+        int clock_control_regs_clock_source;
+        int clock_control_regs_pps_select;
+        int clock_control_regs_pps_out_enb;
+        int clock_control_regs_tcxo_enb;
+        int clock_control_regs_gpsdo_pwr;
 
         //which FPGA image is loaded
         std::string loaded_fpga_image;
@@ -303,6 +303,7 @@
     void update_time_source(mboard_members_t&, const std::string &);
 
     uhd::sensor_value_t get_ref_locked(uhd::wb_iface::sptr);
+    void wait_for_ref_locked(uhd::wb_iface::sptr, double timeout = 0.0);
     bool is_pps_present(uhd::wb_iface::sptr);
 
     void set_db_eeprom(uhd::i2c_iface::sptr i2c, const size_t, const uhd::usrp::dboard_eeprom_t &);
