From 8cfe390ce6300ab48229c2856937779f6b006951 Mon Sep 17 00:00:00 2001
From: "A. Maitland Bottoms" <bottoms@debian.org>
Date: Thu, 5 Dec 2013 22:30:35 -0500
Subject: [PATCH 2/2] revert Coverity fixes

---
 host/examples/network_relay.cpp                  |   17 +++++----
 host/examples/test_dboard_coercion.cpp           |   18 +++++-----
 host/examples/test_messages.cpp                  |    5 ++-
 host/include/uhd/config.hpp                      |    3 --
 host/include/uhd/transport/zero_copy.hpp         |    4 +--
 host/include/uhd/utils/atomic.hpp                |    4 ---
 host/lib/convert/convert_fc32_item32.cpp         |   17 +++++----
 host/lib/convert/convert_pack_sc12.cpp           |    2 +-
 host/lib/convert/convert_unpack_sc12.cpp         |    2 +-
 host/lib/convert/sse2_fc32_to_sc16.cpp           |   38 ++++++--------------
 host/lib/convert/sse2_sc16_to_fc32.cpp           |   38 ++++++--------------
 host/lib/transport/super_recv_packet_handler.hpp |    3 +-
 host/lib/transport/super_send_packet_handler.hpp |    2 +-
 host/lib/transport/udp_zero_copy.cpp             |    3 +-
 host/lib/types/tune.cpp                          |    7 ++--
 host/lib/usrp/b100/usb_zero_copy_wrapper.cpp     |    1 -
 host/lib/usrp/b200/b200_iface.cpp                |   10 ++----
 host/lib/usrp/common/fx2_ctrl.cpp                |    6 ----
 host/lib/usrp/cores/rx_dsp_core_200.cpp          |    5 +--
 host/lib/usrp/cores/rx_dsp_core_3000.cpp         |    5 +--
 host/lib/usrp/cores/rx_frontend_core_200.cpp     |    2 +-
 host/lib/usrp/cores/time64_core_200.cpp          |    1 -
 host/lib/usrp/cores/tx_dsp_core_200.cpp          |    3 --
 host/lib/usrp/cores/tx_dsp_core_3000.cpp         |    3 --
 host/lib/usrp/dboard/db_dbsrx.cpp                |   22 ++++++------
 host/lib/usrp/dboard/db_tvrx.cpp                 |    2 +-
 host/lib/usrp/dboard/db_wbx_common.hpp           |    2 +-
 host/lib/usrp/gps_ctrl.cpp                       |    2 ++
 host/lib/usrp/usrp1/io_impl.cpp                  |    2 +-
 host/lib/usrp/usrp1/usrp1_iface.cpp              |   12 +++----
 host/lib/usrp/usrp2/usrp2_clk_regs.hpp           |   14 ++------
 host/lib/usrp/usrp2/usrp2_iface.cpp              |    2 +-
 host/lib/utils/paths.cpp                         |    5 ++-
 host/tests/sph_recv_test.cpp                     |    8 ++---
 host/tests/time_spec_test.cpp                    |    2 --
 host/utils/b2xx_fx3_utils.cpp                    |   40 ++++++----------------
 36 files changed, 104 insertions(+), 208 deletions(-)

diff --git a/host/examples/network_relay.cpp b/host/examples/network_relay.cpp
index 0a67bbf..433a9e8 100644
--- a/host/examples/network_relay.cpp
+++ b/host/examples/network_relay.cpp
@@ -34,6 +34,8 @@ typedef boost::shared_ptr<asio::ip::udp::socket> socket_type;
 
 static const size_t insane_mtu = 9000;
 
+boost::mutex spawn_mutex;
+
 #if defined(UHD_PLATFORM_MACOS)
     //limit buffer resize on macos or it will error
     const size_t rx_dsp_buff_size = size_t(1e6);
@@ -99,11 +101,14 @@ public:
         }
 
         std::cout << "spawning relay threads... " << _port << std::endl;
-        boost::unique_lock<boost::mutex> lock(spawn_mutex);     // lock in preparation to wait for threads to spawn
         _thread_group.create_thread(boost::bind(&udp_relay_type::server_thread, this));
-        wait_for_thread.wait(lock);      // wait for thread to spin up
+        spawn_mutex.lock();
+        spawn_mutex.lock();
+        spawn_mutex.unlock();
         _thread_group.create_thread(boost::bind(&udp_relay_type::client_thread, this));
-        wait_for_thread.wait(lock);      // wait for thread to spin up
+        spawn_mutex.lock();
+        spawn_mutex.lock();
+        spawn_mutex.unlock();
         std::cout << "    done!" << std::endl << std::endl;
     }
 
@@ -124,7 +129,7 @@ private:
     void server_thread(void){
         uhd::set_thread_priority_safe();
         std::cout << "    entering server_thread..." << std::endl;
-        wait_for_thread.notify_one();    // notify constructor that this thread has started
+        spawn_mutex.unlock();
         std::vector<char> buff(insane_mtu);
         while (not boost::this_thread::interruption_requested()){
             if (wait_for_recv_ready(_server_socket->native())){
@@ -150,7 +155,7 @@ private:
     void client_thread(void){
         uhd::set_thread_priority_safe();
         std::cout << "    entering client_thread..." << std::endl;
-        wait_for_thread.notify_one();    // notify constructor that this thread has started
+        spawn_mutex.unlock();
         std::vector<char> buff(insane_mtu);
         while (not boost::this_thread::interruption_requested()){
             if (wait_for_recv_ready(_client_socket->native())){
@@ -168,8 +173,6 @@ private:
     asio::ip::udp::endpoint _endpoint;
     boost::mutex _endpoint_mutex;
     socket_type _server_socket, _client_socket;
-    boost::mutex spawn_mutex;
-    boost::condition_variable wait_for_thread;
 };
 
 
diff --git a/host/examples/test_dboard_coercion.cpp b/host/examples/test_dboard_coercion.cpp
index 86c59d9..cfc7451 100644
--- a/host/examples/test_dboard_coercion.cpp
+++ b/host/examples/test_dboard_coercion.cpp
@@ -53,7 +53,7 @@ std::string return_USRP_config_string(uhd::usrp::multi_usrp::sptr usrp, bool tes
 
     if(test_tx){
         if(tx_info.get("tx_serial") != "") tx_serial = tx_info.get("tx_serial");
-        else tx_serial = "no serial";
+        else tx_serial = "no serial"; 
         tx_subdev_name = tx_info.get("tx_subdev_name");
         tx_subdev_spec = tx_info.get("tx_subdev_spec");
 
@@ -121,7 +121,7 @@ std::string tx_test(uhd::usrp::multi_usrp::sptr usrp, bool test_gain, bool verbo
             gains.push_back(current_gain);
             current_gain++;
         }
-        gains.push_back(gain_end);
+        if(gain_end != *gains.end()) gains.push_back(gain_end);
 
     }
 
@@ -182,19 +182,19 @@ std::string tx_test(uhd::usrp::multi_usrp::sptr usrp, bool test_gain, bool verbo
         }
 
         if(test_gain){
-
+            
             //Testing for successful gain tune
 
             for(std::vector<double>::iterator g = gains.begin(); g != gains.end(); ++g){
                 usrp->set_tx_gain(*g);
                 boost::this_thread::sleep(boost::posix_time::microseconds(1000));
-
+                
                 double actual_gain = usrp->get_tx_gain();
 
                 if(*g == 0.0){
                     if(actual_gain == 0.0){
                         if(verbose) std::cout << boost::format("TX gain successfully set to %5.2f at TX frequency %s.") % *g % return_MHz_string(*f) << std::endl;
-                    }
+                    }    
                     else{
                         if(verbose) std::cout << boost::format("TX gain set to %5.2f instead of %5.2f at TX frequency %s.") % actual_gain % *g % return_MHz_string(*f) << std::endl;
                         std::vector<double> bad_gain_freq;
@@ -313,7 +313,7 @@ std::string rx_test(uhd::usrp::multi_usrp::sptr usrp, bool test_gain, bool verbo
             gains.push_back(current_gain);
             current_gain++;
         }
-        gains.push_back(gain_end);
+        if(gain_end != *gains.end()) gains.push_back(gain_end);
 
     }
 
@@ -518,7 +518,7 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
         std::cout << "REF must equal internal, external, or mimo." << std::endl;
         return ~0;
     }
-
+ 
     if(vm.count("tx") + vm.count("rx") == 0){
         std::cout << desc << std::endl;
         std::cout << "Specify --tx to test for TX frequency coercion\n"
@@ -557,12 +557,12 @@ int UHD_SAFE_MAIN(int argc, char *argv[]){
         uhd::sensor_value_t mimo_locked = usrp->get_mboard_sensor("mimo_locked",0);
         std::cout << boost::format("Checking MIMO lock: %s ...") % mimo_locked.to_pp_string() << std::endl;
         UHD_ASSERT_THROW(mimo_locked.to_bool());
-    }
+    }   
     if ((ref == "external") and (std::find(sensor_names.begin(), sensor_names.end(), "ref_locked") != sensor_names.end())) {
         uhd::sensor_value_t ref_locked = usrp->get_mboard_sensor("ref_locked",0);
         std::cout << boost::format("Checking REF lock: %s ...") % ref_locked.to_pp_string() << std::endl;
         UHD_ASSERT_THROW(ref_locked.to_bool());
-    }
+    }   
     usrp_config = return_USRP_config_string(usrp, test_tx, test_rx);
     if(test_tx) tx_results = tx_test(usrp, test_tx_gain, verbose);
     if(test_rx) rx_results = rx_test(usrp, test_rx_gain, verbose);
diff --git a/host/examples/test_messages.cpp b/host/examples/test_messages.cpp
index 4240e83..e39a8bd 100644
--- a/host/examples/test_messages.cpp
+++ b/host/examples/test_messages.cpp
@@ -1,5 +1,5 @@
 //
-// Copyright 2010-2013 Ettus Research LLC
+// Copyright 2010-2011 Ettus Research LLC
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -15,7 +15,6 @@
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //
 
-#include <uhd/config.hpp>
 #include <uhd/utils/thread_priority.hpp>
 #include <uhd/utils/safe_main.hpp>
 #include <uhd/utils/static.hpp>
@@ -85,7 +84,7 @@ bool test_late_command_message(uhd::usrp::multi_usrp::sptr usrp, uhd::rx_streame
  *    Issue a stream command with num samps and more.
  *    We expect to get an inline broken chain message.
  */
-bool test_broken_chain_message(UHD_UNUSED(uhd::usrp::multi_usrp::sptr usrp), uhd::rx_streamer::sptr rx_stream, uhd::tx_streamer::sptr){
+bool test_broken_chain_message(uhd::usrp::multi_usrp::sptr usrp, uhd::rx_streamer::sptr rx_stream, uhd::tx_streamer::sptr){
     std::cout << "Test broken chain message... " << std::flush;
 
     uhd::stream_cmd_t stream_cmd(uhd::stream_cmd_t::STREAM_MODE_NUM_SAMPS_AND_MORE);
diff --git a/host/include/uhd/config.hpp b/host/include/uhd/config.hpp
index 619bd07..6fd2932 100644
--- a/host/include/uhd/config.hpp
+++ b/host/include/uhd/config.hpp
@@ -55,21 +55,18 @@ typedef ptrdiff_t ssize_t;
     #define UHD_INLINE         __forceinline
     #define UHD_DEPRECATED     __declspec(deprecated)
     #define UHD_ALIGNED(x)     __declspec(align(x))
-    #define UHD_UNUSED(x)      x
 #elif defined(__GNUG__) && __GNUG__ >= 4
     #define UHD_EXPORT         __attribute__((visibility("default")))
     #define UHD_IMPORT         __attribute__((visibility("default")))
     #define UHD_INLINE         inline __attribute__((always_inline))
     #define UHD_DEPRECATED     __attribute__((deprecated))
     #define UHD_ALIGNED(x)     __attribute__((aligned(x)))
-    #define UHD_UNUSED(x)      x __attribute__((unused))
 #else
     #define UHD_EXPORT
     #define UHD_IMPORT
     #define UHD_INLINE         inline
     #define UHD_DEPRECATED
     #define UHD_ALIGNED(x)
-    #define UHD_UNUSED(x)      x
 #endif
 
 // Define API declaration macro
diff --git a/host/include/uhd/transport/zero_copy.hpp b/host/include/uhd/transport/zero_copy.hpp
index 40d7b8c..fe2974d 100644
--- a/host/include/uhd/transport/zero_copy.hpp
+++ b/host/include/uhd/transport/zero_copy.hpp
@@ -29,9 +29,7 @@ namespace uhd{ namespace transport{
     //! Simple managed buffer with release interface
     class UHD_API managed_buffer{
     public:
-        managed_buffer(void):_ref_count(0),_buffer(NULL),_length(0){}
-
-        virtual ~managed_buffer(void) {}
+        managed_buffer(void):_ref_count(0){}
 
         /*!
          * Signal to the transport that we are done with the buffer.
diff --git a/host/include/uhd/utils/atomic.hpp b/host/include/uhd/utils/atomic.hpp
index 55769d2..8ddee73 100644
--- a/host/include/uhd/utils/atomic.hpp
+++ b/host/include/uhd/utils/atomic.hpp
@@ -78,10 +78,6 @@ namespace uhd{
     class UHD_API reusable_barrier{
     public:
 
-        reusable_barrier():_size (0) {}
-
-        reusable_barrier(const size_t size):_size(size) {}
-
         //! Resize the barrier for N threads
         void resize(const size_t size){
             _size = size;
diff --git a/host/lib/convert/convert_fc32_item32.cpp b/host/lib/convert/convert_fc32_item32.cpp
index 641fc26..29bfefd 100644
--- a/host/lib/convert/convert_fc32_item32.cpp
+++ b/host/lib/convert/convert_fc32_item32.cpp
@@ -28,7 +28,7 @@ typedef boost::uint32_t (*to32_type)(boost::uint32_t);
 template <typename type, to32_type tohost>
 struct convert_fc32_item32_1_to_star_1 : public converter
 {
-    convert_fc32_item32_1_to_star_1(void):_scalar(0.0)
+    convert_fc32_item32_1_to_star_1(void)
     {
         //NOP
     }
@@ -48,9 +48,9 @@ struct convert_fc32_item32_1_to_star_1 : public converter
         {
             const item32_t i32 = tohost(input[i++]);
             const item32_t q32 = tohost(input[i++]);
-            const float *i_f32p = reinterpret_cast<const float *>(&i32);
-            const float *q_f32p = reinterpret_cast<const float *>(&q32);
-            output[o] = std::complex<type>(type((*i_f32p)*_scalar), type((*q_f32p)*_scalar));
+            const float i_f32 = reinterpret_cast<const float &>(i32);
+            const float q_f32 = reinterpret_cast<const float &>(q32);
+            output[o] = std::complex<type>(type(i_f32*_scalar), type(q_f32*_scalar));
         }
     }
 
@@ -60,7 +60,7 @@ struct convert_fc32_item32_1_to_star_1 : public converter
 template <typename type, to32_type towire>
 struct convert_star_1_to_fc32_item32_1 : public converter
 {
-    convert_star_1_to_fc32_item32_1(void):_scalar(0.0)
+    convert_star_1_to_fc32_item32_1(void)
     {
         //NOP
     }
@@ -80,10 +80,9 @@ struct convert_star_1_to_fc32_item32_1 : public converter
         {
             const float i_f32 = type(input[i].real()*_scalar);
             const float q_f32 = type(input[i].imag()*_scalar);
-            const item32_t *i32p = reinterpret_cast<const item32_t *>(&i_f32);
-            const item32_t *q32p = reinterpret_cast<const item32_t *>(&q_f32);
-            output[o++] = towire(*i32p);
-            output[o++] = towire(*q32p);
+            const item32_t i32 = towire(reinterpret_cast<const item32_t &>(i_f32));
+            const item32_t q32 = towire(reinterpret_cast<const item32_t &>(q_f32));
+            output[o++] = i32; output[o++] = q32;
         }
     }
 
diff --git a/host/lib/convert/convert_pack_sc12.cpp b/host/lib/convert/convert_pack_sc12.cpp
index 92cd5d1..6808149 100644
--- a/host/lib/convert/convert_pack_sc12.cpp
+++ b/host/lib/convert/convert_pack_sc12.cpp
@@ -67,7 +67,7 @@ void convert_star_4_to_sc12_item32_3
 template <typename type, towire32_type towire>
 struct convert_star_1_to_sc12_item32_1 : public converter
 {
-    convert_star_1_to_sc12_item32_1(void):_scalar(0.0)
+    convert_star_1_to_sc12_item32_1(void)
     {
         //NOP
     }
diff --git a/host/lib/convert/convert_unpack_sc12.cpp b/host/lib/convert/convert_unpack_sc12.cpp
index a2aec2a..e98ab73 100644
--- a/host/lib/convert/convert_unpack_sc12.cpp
+++ b/host/lib/convert/convert_unpack_sc12.cpp
@@ -84,7 +84,7 @@ void convert_sc12_item32_3_to_star_4
 template <typename type, tohost32_type tohost>
 struct convert_sc12_item32_1_to_star_1 : public converter
 {
-    convert_sc12_item32_1_to_star_1(void):_scalar(0.0)
+    convert_sc12_item32_1_to_star_1(void)
     {
         //NOP
     }
diff --git a/host/lib/convert/sse2_fc32_to_sc16.cpp b/host/lib/convert/sse2_fc32_to_sc16.cpp
index a83e9b4..90bf0ed 100644
--- a/host/lib/convert/sse2_fc32_to_sc16.cpp
+++ b/host/lib/convert/sse2_fc32_to_sc16.cpp
@@ -27,7 +27,6 @@ DECLARE_CONVERTER(fc32, 1, sc16_item32_le, 1, PRIORITY_SIMD){
 
     const __m128 scalar = _mm_set_ps1(float(scale_factor));
 
-    // this macro converts values faster by using SSE intrinsics to convert 4 values at a time
     #define convert_fc32_1_to_item32_1_nswap_guts(_al_)                 \
     for (; i+3 < nsamps; i+=4){                                         \
         /* load from input */                                           \
@@ -49,25 +48,17 @@ DECLARE_CONVERTER(fc32, 1, sc16_item32_le, 1, PRIORITY_SIMD){
 
     size_t i = 0;
 
-    // need to dispatch according to alignment for fastest conversion
+    //dispatch according to alignment
     switch (size_t(input) & 0xf){
-    case 0x0:
-        // the data is 16-byte aligned, so do the fast processing of the bulk of the samples
-        convert_fc32_1_to_item32_1_nswap_guts(_)
-        break;
     case 0x8:
-        // the first sample is 8-byte aligned - process it to align the remainder of the samples to 16-bytes
-        xx_to_item32_sc16<uhd::htowx>(input, output, 1, scale_factor);
-        i++;
-        // do faster processing of the bulk of the samples now that we are 16-byte aligned
+        xx_to_item32_sc16<uhd::htowx>(input, output, 1, scale_factor); i++;
+    case 0x0:
         convert_fc32_1_to_item32_1_nswap_guts(_)
         break;
-    default:
-        // we are not 8 or 16-byte aligned, so do fast processing with the unaligned load
-        convert_fc32_1_to_item32_1_nswap_guts(u_)
+    default: convert_fc32_1_to_item32_1_nswap_guts(u_)
     }
 
-    // convert any remaining samples
+    //convert remainder
     xx_to_item32_sc16<uhd::htowx>(input+i, output+i, nsamps-i, scale_factor);
 }
 
@@ -77,7 +68,6 @@ DECLARE_CONVERTER(fc32, 1, sc16_item32_be, 1, PRIORITY_SIMD){
 
     const __m128 scalar = _mm_set_ps1(float(scale_factor));
 
-    // this macro converts values faster by using SSE intrinsics to convert 4 values at a time
     #define convert_fc32_1_to_item32_1_bswap_guts(_al_)                 \
     for (; i+3 < nsamps; i+=4){                                         \
         /* load from input */                                           \
@@ -98,24 +88,16 @@ DECLARE_CONVERTER(fc32, 1, sc16_item32_be, 1, PRIORITY_SIMD){
 
     size_t i = 0;
 
-    // need to dispatch according to alignment for fastest conversion
+    //dispatch according to alignment
     switch (size_t(input) & 0xf){
-    case 0x0:
-        // the data is 16-byte aligned, so do the fast processing of the bulk of the samples
-        convert_fc32_1_to_item32_1_bswap_guts(_)
     case 0x8:
-        // the first value is 8-byte aligned - process it and prepare the bulk of the data for fast conversion
-        xx_to_item32_sc16<uhd::htonx>(input, output, 1, scale_factor);
-        i++;
-        // do faster processing of the remaining samples now that we are 16-byte aligned
+        xx_to_item32_sc16<uhd::htonx>(input, output, 1, scale_factor); i++;
+    case 0x0:
         convert_fc32_1_to_item32_1_bswap_guts(_)
         break;
-        break;
-    default:
-        // we are not 8 or 16-byte aligned, so do fast processing with the unaligned load
-        convert_fc32_1_to_item32_1_bswap_guts(u_)
+    default: convert_fc32_1_to_item32_1_bswap_guts(u_)
     }
 
-    // convert any remaining samples
+    //convert remainder
     xx_to_item32_sc16<uhd::htonx>(input+i, output+i, nsamps-i, scale_factor);
 }
diff --git a/host/lib/convert/sse2_sc16_to_fc32.cpp b/host/lib/convert/sse2_sc16_to_fc32.cpp
index 0ac7f17..c03e415 100644
--- a/host/lib/convert/sse2_sc16_to_fc32.cpp
+++ b/host/lib/convert/sse2_sc16_to_fc32.cpp
@@ -28,7 +28,6 @@ DECLARE_CONVERTER(sc16_item32_le, 1, fc32, 1, PRIORITY_SIMD){
     const __m128 scalar = _mm_set_ps1(float(scale_factor)/(1 << 16));
     const __m128i zeroi = _mm_setzero_si128();
 
-    // this macro converts values faster by using SSE intrinsics to convert 4 values at a time
     #define convert_item32_1_to_fc32_1_nswap_guts(_al_)                 \
     for (; i+3 < nsamps; i+=4){                                         \
         /* load from input */                                           \
@@ -51,25 +50,17 @@ DECLARE_CONVERTER(sc16_item32_le, 1, fc32, 1, PRIORITY_SIMD){
 
     size_t i = 0;
 
-    // need to dispatch according to alignment for fastest conversion
+    //dispatch according to alignment
     switch (size_t(output) & 0xf){
-    case 0x0:
-        // the data is 16-byte aligned, so do the fast processing of the bulk of the samples
-        convert_item32_1_to_fc32_1_nswap_guts(_)
-        break;
     case 0x8:
-        // the first sample is 8-byte aligned - process it to align the remainder of the samples to 16-bytes
-        item32_sc16_to_xx<uhd::htowx>(input, output, 1, scale_factor);
-        i++;
-        // do faster processing of the bulk of the samples now that we are 16-byte aligned
+        item32_sc16_to_xx<uhd::htowx>(input, output, 1, scale_factor); i++;
+    case 0x0:
         convert_item32_1_to_fc32_1_nswap_guts(_)
         break;
-    default:
-        // we are not 8 or 16-byte aligned, so do fast processing with the unaligned load and store
-        convert_item32_1_to_fc32_1_nswap_guts(u_)
+    default: convert_item32_1_to_fc32_1_nswap_guts(u_)
     }
 
-    // convert any remaining samples
+    //convert remainder
     item32_sc16_to_xx<uhd::htowx>(input+i, output+i, nsamps-i, scale_factor);
 }
 
@@ -80,7 +71,6 @@ DECLARE_CONVERTER(sc16_item32_be, 1, fc32, 1, PRIORITY_SIMD){
     const __m128 scalar = _mm_set_ps1(float(scale_factor)/(1 << 16));
     const __m128i zeroi = _mm_setzero_si128();
 
-    // this macro converts values faster by using SSE intrinsics to convert 4 values at a time
     #define convert_item32_1_to_fc32_1_bswap_guts(_al_)                 \
     for (; i+3 < nsamps; i+=4){                                         \
         /* load from input */                                           \
@@ -102,24 +92,16 @@ DECLARE_CONVERTER(sc16_item32_be, 1, fc32, 1, PRIORITY_SIMD){
 
     size_t i = 0;
 
-    // need to dispatch according to alignment for fastest conversion
+    //dispatch according to alignment
     switch (size_t(output) & 0xf){
-    case 0x0:
-        // the data is 16-byte aligned, so do the fast processing of the bulk of the samples
-        convert_item32_1_to_fc32_1_bswap_guts(_)
-        break;
     case 0x8:
-        // the first sample is 8-byte aligned - process it to align the remainder of the samples to 16-bytes
-        item32_sc16_to_xx<uhd::htonx>(input, output, 1, scale_factor);
-        i++;
-        // do faster processing of the bulk of the samples now that we are 16-byte aligned
+        item32_sc16_to_xx<uhd::htonx>(input, output, 1, scale_factor); i++;
+    case 0x0:
         convert_item32_1_to_fc32_1_bswap_guts(_)
         break;
-    default:
-        // we are not 8 or 16-byte aligned, so do fast processing with the unaligned load and store
-        convert_item32_1_to_fc32_1_bswap_guts(u_)
+    default: convert_item32_1_to_fc32_1_bswap_guts(u_)
     }
 
-    // convert any remaining samples
+    //convert remainder
     item32_sc16_to_xx<uhd::htonx>(input+i, output+i, nsamps-i, scale_factor);
 }
diff --git a/host/lib/transport/super_recv_packet_handler.hpp b/host/lib/transport/super_recv_packet_handler.hpp
index 5080182..688228e 100644
--- a/host/lib/transport/super_recv_packet_handler.hpp
+++ b/host/lib/transport/super_recv_packet_handler.hpp
@@ -246,8 +246,7 @@ private:
     struct xport_chan_props_type{
         xport_chan_props_type(void):
             packet_count(0),
-            handle_overflow(&handle_overflow_nop),
-            fc_update_window(0)
+            handle_overflow(&handle_overflow_nop)
         {}
         get_buff_type get_buff;
         issue_stream_cmd_type issue_stream_cmd;
diff --git a/host/lib/transport/super_send_packet_handler.hpp b/host/lib/transport/super_send_packet_handler.hpp
index ae483d1..41f030e 100644
--- a/host/lib/transport/super_send_packet_handler.hpp
+++ b/host/lib/transport/super_send_packet_handler.hpp
@@ -239,7 +239,7 @@ private:
     size_t _header_offset_words32;
     double _tick_rate, _samp_rate;
     struct xport_chan_props_type{
-        xport_chan_props_type(void):has_sid(false),sid(0){}
+        xport_chan_props_type(void):has_sid(false){}
         get_buff_type get_buff;
         bool has_sid;
         boost::uint32_t sid;
diff --git a/host/lib/transport/udp_zero_copy.cpp b/host/lib/transport/udp_zero_copy.cpp
index 7b6a476..1661771 100644
--- a/host/lib/transport/udp_zero_copy.cpp
+++ b/host/lib/transport/udp_zero_copy.cpp
@@ -68,7 +68,7 @@ static void check_registry_for_fast_send_threshold(const size_t mtu){
 class udp_zero_copy_asio_mrb : public managed_recv_buffer{
 public:
     udp_zero_copy_asio_mrb(void *mem, int sock_fd, const size_t frame_size):
-        _mem(mem), _sock_fd(sock_fd), _frame_size(frame_size), _len(0) { /*NOP*/ }
+        _mem(mem), _sock_fd(sock_fd), _frame_size(frame_size) { /*NOP*/ }
 
     void release(void){
         _claimer.release();
@@ -87,7 +87,6 @@ public:
 
         if (wait_for_recv_ready(_sock_fd, timeout)){
             _len = ::recv(_sock_fd, (char *)_mem, _frame_size, 0);
-            UHD_ASSERT_THROW(_len > 0); // TODO: Handle case of recv error
             index++; //advances the caller's buffer
             return make(this, _mem, size_t(_len));
         }
diff --git a/host/lib/types/tune.cpp b/host/lib/types/tune.cpp
index 7697bd9..154f099 100644
--- a/host/lib/types/tune.cpp
+++ b/host/lib/types/tune.cpp
@@ -24,9 +24,7 @@ using namespace uhd;
 tune_request_t::tune_request_t(double target_freq):
     target_freq(target_freq),
     rf_freq_policy(POLICY_AUTO),
-    rf_freq(0.0),
-    dsp_freq_policy(POLICY_AUTO),
-    dsp_freq(0.0)
+    dsp_freq_policy(POLICY_AUTO)
 {
     /* NOP */
 }
@@ -35,8 +33,7 @@ tune_request_t::tune_request_t(double target_freq, double lo_off):
     target_freq(target_freq),
     rf_freq_policy(POLICY_MANUAL),
     rf_freq(target_freq + lo_off),
-    dsp_freq_policy(POLICY_AUTO),
-    dsp_freq(0.0)
+    dsp_freq_policy(POLICY_AUTO)
 {
     /* NOP */
 }
diff --git a/host/lib/usrp/b100/usb_zero_copy_wrapper.cpp b/host/lib/usrp/b100/usb_zero_copy_wrapper.cpp
index 451cdae..2096e4e 100644
--- a/host/lib/usrp/b100/usb_zero_copy_wrapper.cpp
+++ b/host/lib/usrp/b100/usb_zero_copy_wrapper.cpp
@@ -167,7 +167,6 @@ public:
     usb_zero_copy_wrapper(zero_copy_if::sptr usb_zc, const size_t frame_boundary):
         _internal_zc(usb_zc),
         _frame_boundary(frame_boundary),
-        _last_recv_offset(0),
         _next_recv_buff_index(0)
     {
         for (size_t i = 0; i < this->get_num_recv_frames(); i++){
diff --git a/host/lib/usrp/b200/b200_iface.cpp b/host/lib/usrp/b200/b200_iface.cpp
index 7809781..29d1194 100644
--- a/host/lib/usrp/b200/b200_iface.cpp
+++ b/host/lib/usrp/b200/b200_iface.cpp
@@ -17,7 +17,6 @@
 
 #include "b200_iface.hpp"
 
-#include <uhd/config.hpp>
 #include <uhd/utils/msg.hpp>
 #include <uhd/exception.hpp>
 #include <boost/functional/hash.hpp>
@@ -221,13 +220,13 @@ public:
                                    timeout);            // timeout
     }
 
-    void write_i2c(UHD_UNUSED(boost::uint16_t addr), UHD_UNUSED(const byte_vector_t &bytes))
+    void write_i2c(boost::uint16_t addr, const byte_vector_t &bytes)
     {
         throw uhd::not_implemented_error("b200 write i2c");
     }
 
 
-    byte_vector_t read_i2c(UHD_UNUSED(boost::uint16_t addr), UHD_UNUSED(size_t num_bytes))
+    byte_vector_t read_i2c(boost::uint16_t addr, size_t num_bytes)
     {
         throw uhd::not_implemented_error("b200 read i2c");
     }
@@ -322,7 +321,7 @@ public:
         throw uhd::io_error(str(boost::format("Failed to read complete AD9361 (expecting: %d, last read: %d)") % bytes_to_read % ret));
     }
 
-    void load_firmware(const std::string filestring, UHD_UNUSED(bool force) = false)
+    void load_firmware(const std::string filestring, bool force = false)
     {
         const char *filename = filestring.c_str();
 
@@ -352,9 +351,6 @@ public:
             std::string record;
             file >> record;
 
-        if (!(record.length() > 0))
-            continue;
-
             /* Check for valid Intel HEX record. */
             if (!checksum(record) || !parse_record(record, len, \
                         lower_address_bits, type, data)) {
diff --git a/host/lib/usrp/common/fx2_ctrl.cpp b/host/lib/usrp/common/fx2_ctrl.cpp
index d68bf60..6111efe 100644
--- a/host/lib/usrp/common/fx2_ctrl.cpp
+++ b/host/lib/usrp/common/fx2_ctrl.cpp
@@ -119,9 +119,6 @@ bool parse_record(std::string *record, unsigned int &len,
     std::istringstream(record->substr(3, 4)) >> std::hex >> addr;
     std::istringstream(record->substr(7, 2)) >> std::hex >> type;
 
-    if (len > (2 * (record->length() - 9)))  // sanity check to prevent buffer overrun
-        return false;
-
     for (i = 0; i < len; i++) {
         std::istringstream(record->substr(9 + 2 * i, 2)) >> std::hex >> val;
         data[i] = (unsigned char) val;
@@ -184,9 +181,6 @@ public:
            std::string record;
            file >> record;
 
-        if (!(record.length() > 0))
-            continue;
-
             //check for valid record
             if (not checksum(&record) or not parse_record(&record, len, addr, type, data)) {
                 throw uhd::io_error("usrp_load_firmware: bad record checksum");
diff --git a/host/lib/usrp/cores/rx_dsp_core_200.cpp b/host/lib/usrp/cores/rx_dsp_core_200.cpp
index 2fdc220..ef6b85d 100644
--- a/host/lib/usrp/cores/rx_dsp_core_200.cpp
+++ b/host/lib/usrp/cores/rx_dsp_core_200.cpp
@@ -59,11 +59,8 @@ public:
         const size_t dsp_base, const size_t ctrl_base,
         const boost::uint32_t sid, const bool lingering_packet
     ):
-        _iface(iface), _dsp_base(dsp_base), _ctrl_base(ctrl_base),  _sid(sid)
+        _iface(iface), _dsp_base(dsp_base), _ctrl_base(ctrl_base), _sid(sid)
     {
-        // previously uninitialized - assuming zero for all
-        _tick_rate = _link_rate = _host_extra_scaling = _fxpt_scalar_correction = 0.0;
-
         //init to something so update method has reasonable defaults
         _scaling_adjustment = 1.0;
         _dsp_extra_scaling = 1.0;
diff --git a/host/lib/usrp/cores/rx_dsp_core_3000.cpp b/host/lib/usrp/cores/rx_dsp_core_3000.cpp
index 5259160..7b3324f 100644
--- a/host/lib/usrp/cores/rx_dsp_core_3000.cpp
+++ b/host/lib/usrp/cores/rx_dsp_core_3000.cpp
@@ -50,13 +50,10 @@ public:
     ):
         _iface(iface), _dsp_base(dsp_base)
     {
-        // previously uninitialized - assuming zero for all
-        _link_rate = _host_extra_scaling = _fxpt_scalar_correction = 0.0;
-
         //init to something so update method has reasonable defaults
         _scaling_adjustment = 1.0;
         _dsp_extra_scaling = 1.0;
-        _tick_rate = 1.0;
+        this->set_tick_rate(1.0);
     }
 
     ~rx_dsp_core_3000_impl(void)
diff --git a/host/lib/usrp/cores/rx_frontend_core_200.cpp b/host/lib/usrp/cores/rx_frontend_core_200.cpp
index 864b5cc..09b36c1 100644
--- a/host/lib/usrp/cores/rx_frontend_core_200.cpp
+++ b/host/lib/usrp/cores/rx_frontend_core_200.cpp
@@ -38,7 +38,7 @@ static boost::uint32_t fs_to_bits(const double num, const size_t bits){
 class rx_frontend_core_200_impl : public rx_frontend_core_200{
 public:
     rx_frontend_core_200_impl(wb_iface::sptr iface, const size_t base):
-        _i_dc_off(0), _q_dc_off(0), _iface(iface), _base(base)
+        _iface(iface), _base(base)
     {
         //NOP
     }
diff --git a/host/lib/usrp/cores/time64_core_200.cpp b/host/lib/usrp/cores/time64_core_200.cpp
index ad5e647..11b3103 100644
--- a/host/lib/usrp/cores/time64_core_200.cpp
+++ b/host/lib/usrp/cores/time64_core_200.cpp
@@ -48,7 +48,6 @@ public:
     ):
         _iface(iface), _base(base),
         _readback_bases(readback_bases),
-        _tick_rate(0.0),
         _mimo_delay_cycles(mimo_delay_cycles)
     {
         _sources.push_back("none");
diff --git a/host/lib/usrp/cores/tx_dsp_core_200.cpp b/host/lib/usrp/cores/tx_dsp_core_200.cpp
index f8aa87a..808f130 100644
--- a/host/lib/usrp/cores/tx_dsp_core_200.cpp
+++ b/host/lib/usrp/cores/tx_dsp_core_200.cpp
@@ -60,9 +60,6 @@ public:
     ):
         _iface(iface), _dsp_base(dsp_base), _ctrl_base(ctrl_base), _sid(sid)
     {
-        // previously uninitialized - assuming zero for all
-        _tick_rate = _link_rate = _host_extra_scaling = _fxpt_scalar_correction = 0.0;
-
         //init to something so update method has reasonable defaults
         _scaling_adjustment = 1.0;
         _dsp_extra_scaling = 1.0;
diff --git a/host/lib/usrp/cores/tx_dsp_core_3000.cpp b/host/lib/usrp/cores/tx_dsp_core_3000.cpp
index 93c8702..feb749c 100644
--- a/host/lib/usrp/cores/tx_dsp_core_3000.cpp
+++ b/host/lib/usrp/cores/tx_dsp_core_3000.cpp
@@ -45,9 +45,6 @@ public:
     ):
         _iface(iface), _dsp_base(dsp_base)
     {
-        // previously uninitialized - assuming zero for all
-        _link_rate = _host_extra_scaling = _fxpt_scalar_correction = 0.0;
-
         //init to something so update method has reasonable defaults
         _scaling_adjustment = 1.0;
         _dsp_extra_scaling = 1.0;
diff --git a/host/lib/usrp/dboard/db_dbsrx.cpp b/host/lib/usrp/dboard/db_dbsrx.cpp
index 9d04d8e..b1cee4a 100644
--- a/host/lib/usrp/dboard/db_dbsrx.cpp
+++ b/host/lib/usrp/dboard/db_dbsrx.cpp
@@ -179,7 +179,7 @@ dbsrx::dbsrx(ctor_args_t args) : rx_dboard_base(args){
                 "DBSRX: incorrect dbid\n"
                 "Expected dbid 0x0002 and R193\n"
                 "found dbid == %d\n"
-                "Please see the daughterboard app notes"
+                "Please see the daughterboard app notes" 
                 ) % this->get_rx_id().to_pp_string();
 
     //warn user about incorrect DBID on non-USRP1, requires R194 populated
@@ -188,7 +188,7 @@ dbsrx::dbsrx(ctor_args_t args) : rx_dboard_base(args){
                 "DBSRX: incorrect dbid\n"
                 "Expected dbid 0x000D and R194\n"
                 "found dbid == %d\n"
-                "Please see the daughterboard app notes"
+                "Please see the daughterboard app notes" 
                 ) % this->get_rx_id().to_pp_string();
 
     //send initial register settings
@@ -305,13 +305,13 @@ double dbsrx::set_lo_freq(double target_freq){
 
             goto done_loop;
         }
-    }
+    } 
 
     done_loop:
 
-    //Assert because we failed to find a suitable combination of ref_clock, R and N
+    //Assert because we failed to find a suitable combination of ref_clock, R and N 
     UHD_ASSERT_THROW(ref_clock <= 27.0e6 and ref_clock >= 0.0);
-    UHD_ASSERT_THROW(m and ref_clock/m >= 1e6 and ref_clock/m <= 2.5e6);
+    UHD_ASSERT_THROW(ref_clock/m >= 1e6 and ref_clock/m <= 2.5e6);
     UHD_ASSERT_THROW((pfd_freq >= dbsrx_pfd_freq_range.start()) and (pfd_freq <= dbsrx_pfd_freq_range.stop()));
     UHD_ASSERT_THROW((N >= 256) and (N <= 32768));
 
@@ -332,7 +332,7 @@ double dbsrx::set_lo_freq(double target_freq){
     _max2118_write_regs.r_divider = (max2118_write_regs_t::r_divider_t) r;
     _max2118_write_regs.set_n_divider(N);
     _max2118_write_regs.ade_vco_ade_read = max2118_write_regs_t::ADE_VCO_ADE_READ_ENABLED;
-
+    
     //compute prescaler variables
     int scaler = actual_freq > 1125e6 ? 2 : 4;
     _max2118_write_regs.div2 = scaler == 4 ? max2118_write_regs_t::DIV2_DIV4 : max2118_write_regs_t::DIV2_DIV2;
@@ -377,7 +377,7 @@ double dbsrx::set_lo_freq(double target_freq){
         if (_max2118_read_regs.adc == 0){
             if (_max2118_write_regs.osc_band == 0){
                 UHD_MSG(warning) << boost::format(
-                        "DBSRX: Tuning exceeded vco range, _max2118_write_regs.osc_band == %d\n"
+                        "DBSRX: Tuning exceeded vco range, _max2118_write_regs.osc_band == %d\n" 
                         ) % int(_max2118_write_regs.osc_band);
                 UHD_ASSERT_THROW(_max2118_read_regs.adc != 0); //just to cause a throw
             }
@@ -389,7 +389,7 @@ double dbsrx::set_lo_freq(double target_freq){
         if (_max2118_read_regs.adc == 7){
             if (_max2118_write_regs.osc_band == 7){
                 UHD_MSG(warning) << boost::format(
-                        "DBSRX: Tuning exceeded vco range, _max2118_write_regs.osc_band == %d\n"
+                        "DBSRX: Tuning exceeded vco range, _max2118_write_regs.osc_band == %d\n" 
                         ) % int(_max2118_write_regs.osc_band);
                 UHD_ASSERT_THROW(_max2118_read_regs.adc != 7); //just to cause a throw
             }
@@ -408,7 +408,7 @@ double dbsrx::set_lo_freq(double target_freq){
         //allow for setup time before checking condition again
         boost::this_thread::sleep(boost::posix_time::milliseconds(10));
     }
-
+      
     UHD_LOGV(often) << boost::format(
         "DBSRX: final vco %d, vtune adc %d"
     ) % int(_max2118_write_regs.osc_band) % int(_max2118_read_regs.adc) << std::endl;
@@ -417,7 +417,7 @@ double dbsrx::set_lo_freq(double target_freq){
     if (_max2118_read_regs.adc <= 2) _max2118_write_regs.cp_current = max2118_write_regs_t::CP_CURRENT_I_CP_100UA;
     else if (_max2118_read_regs.adc >= 5) _max2118_write_regs.cp_current = max2118_write_regs_t::CP_CURRENT_I_CP_400UA;
     else _max2118_write_regs.cp_current = max2118_write_regs_t::CP_CURRENT_I_CP_200UA;
-
+    
     //update charge pump bias current setting
     send_reg(0x2, 0x2);
 
@@ -524,7 +524,7 @@ double dbsrx::set_bandwidth(double bandwidth){
     bandwidth = dbsrx_bandwidth_range.clip(bandwidth);
 
     double ref_clock = this->get_iface()->get_clock_rate(dboard_iface::UNIT_RX);
-
+    
     //NOTE: _max2118_write_regs.m_divider set in set_lo_freq
 
     //compute f_dac setting
diff --git a/host/lib/usrp/dboard/db_tvrx.cpp b/host/lib/usrp/dboard/db_tvrx.cpp
index e9f60f7..edee46c 100644
--- a/host/lib/usrp/dboard/db_tvrx.cpp
+++ b/host/lib/usrp/dboard/db_tvrx.cpp
@@ -267,7 +267,7 @@ static std::string get_band(double freq) {
  * \return a voltage to feed the TVRX analog gain
  */
 
-static double gain_interp(double gain, const boost::array<double, 17>& db_vector, const boost::array<double, 17>& volts_vector) {
+static double gain_interp(double gain, boost::array<double, 17> db_vector, boost::array<double, 17> volts_vector) {
     double volts;
     gain = uhd::clip<double>(gain, db_vector.front(), db_vector.back()); //let's not get carried away here
 
diff --git a/host/lib/usrp/dboard/db_wbx_common.hpp b/host/lib/usrp/dboard/db_wbx_common.hpp
index d1beb16..9e984dc 100644
--- a/host/lib/usrp/dboard/db_wbx_common.hpp
+++ b/host/lib/usrp/dboard/db_wbx_common.hpp
@@ -118,7 +118,7 @@ protected:
      */
     class wbx_versionx {
     public:
-        wbx_versionx():self_base(NULL) {}
+        wbx_versionx() {}
         ~wbx_versionx(void) {}
 
         virtual double set_tx_gain(double gain, const std::string &name) = 0;
diff --git a/host/lib/usrp/gps_ctrl.cpp b/host/lib/usrp/gps_ctrl.cpp
index 105a52b..c3af75f 100644
--- a/host/lib/usrp/gps_ctrl.cpp
+++ b/host/lib/usrp/gps_ctrl.cpp
@@ -223,6 +223,7 @@ private:
         boost::this_thread::sleep(milliseconds(GPS_TIMEOUT_DELAY_MS));
     }
     throw uhd::value_error(str(boost::format("get_nmea(): no %s message found") % msgtype));
+    return std::string();
   }
 
   //helper function to retrieve a field from an NMEA sentence
@@ -321,6 +322,7 @@ private:
         boost::this_thread::sleep(milliseconds(GPS_TIMEOUT_DELAY_MS));
     }
     throw uhd::value_error("get_stat(): no servo message found");
+    return std::string();
   }
 
   uart_iface::sptr _uart;
diff --git a/host/lib/usrp/usrp1/io_impl.cpp b/host/lib/usrp/usrp1/io_impl.cpp
index e1f17e5..d384eb1 100644
--- a/host/lib/usrp/usrp1/io_impl.cpp
+++ b/host/lib/usrp/usrp1/io_impl.cpp
@@ -63,7 +63,7 @@ static const size_t alignment_padding = 512;
  * Helper struct to associate an offset with a buffer
  **********************************************************************/
 struct offset_send_buffer{
-    offset_send_buffer(void):offset(0){
+    offset_send_buffer(void){
         /* NOP */
     }
 
diff --git a/host/lib/usrp/usrp1/usrp1_iface.cpp b/host/lib/usrp/usrp1/usrp1_iface.cpp
index 6eff9d3..9301721 100644
--- a/host/lib/usrp/usrp1/usrp1_iface.cpp
+++ b/host/lib/usrp/usrp1/usrp1_iface.cpp
@@ -91,11 +91,11 @@ public:
 
         return uhd::ntohx(value_out);
     }
-
+    
     void poke16(boost::uint32_t, boost::uint16_t) {
         throw uhd::not_implemented_error("Unhandled command poke16()");
     }
-
+    
     boost::uint16_t peek16(boost::uint32_t) {
         throw uhd::not_implemented_error("Unhandled command peek16()");
         return 0;
@@ -141,10 +141,8 @@ public:
 
         if (readback) {
             unsigned char buff[4] = {
-                (unsigned char)(bits & 0xff),
-                (unsigned char)((bits >> 8) & 0xff),
-                (unsigned char)((bits >> 16) & 0xff),
-                (unsigned char)((bits >> 24) & 0xff)
+                (bits >> 0) & 0xff, (bits >> 8) & 0xff,
+                (bits >> 16) & 0xff, (bits >> 24) & 0xff
             };
             //conditions where there are two header bytes
             if (num_bytes >= 3 and buff[num_bytes-1] != 0 and buff[num_bytes-2] != 0 and buff[num_bytes-3] == 0){
@@ -170,7 +168,7 @@ public:
                                   (((boost::uint32_t)buff[1]) <<  8) |
                                   (((boost::uint32_t)buff[2]) << 16) |
                                   (((boost::uint32_t)buff[3]) << 24);
-            return val;
+            return val; 
         }
         else {
             // Byteswap on num_bytes
diff --git a/host/lib/usrp/usrp2/usrp2_clk_regs.hpp b/host/lib/usrp/usrp2/usrp2_clk_regs.hpp
index d5e506d..8b185ea 100644
--- a/host/lib/usrp/usrp2/usrp2_clk_regs.hpp
+++ b/host/lib/usrp/usrp2/usrp2_clk_regs.hpp
@@ -22,18 +22,8 @@
 
 class usrp2_clk_regs_t {
 public:
-  usrp2_clk_regs_t(void):
-    test(0),
-    fpga(0),
-    adc(0),
-    dac(0),
-    serdes(0),
-    exp(0),
-    tx_db(0),
-    rx_db(0) {}
-
+  usrp2_clk_regs_t(void) { ; }
   usrp2_clk_regs_t(usrp2_iface::rev_type rev) {
-    fpga = adc = serdes = exp = tx_db = 0;
     test = 0;
     fpga = 1;
     dac = 3;
@@ -64,7 +54,7 @@ public:
         //dont throw, it may be unitialized
         break;
     }
-
+    
     rx_db = 7;
   }
 
diff --git a/host/lib/usrp/usrp2/usrp2_iface.cpp b/host/lib/usrp/usrp2/usrp2_iface.cpp
index 5f97045..3b230ca 100644
--- a/host/lib/usrp/usrp2/usrp2_iface.cpp
+++ b/host/lib/usrp/usrp2/usrp2_iface.cpp
@@ -271,7 +271,7 @@ public:
         //send and recv
         usrp2_ctrl_data_t in_data = this->ctrl_send_and_recv(out_data, MIN_PROTO_COMPAT_I2C);
         UHD_ASSERT_THROW(ntohl(in_data.id) == USRP2_CTRL_ID_HERES_THE_I2C_DATA_DUDE);
-        UHD_ASSERT_THROW(in_data.data.i2c_args.bytes == num_bytes);
+        UHD_ASSERT_THROW(in_data.data.i2c_args.addr = num_bytes);
 
         //copy out the data
         byte_vector_t result(num_bytes);
diff --git a/host/lib/utils/paths.cpp b/host/lib/utils/paths.cpp
index 3e2bea1..25cade6 100644
--- a/host/lib/utils/paths.cpp
+++ b/host/lib/utils/paths.cpp
@@ -115,8 +115,8 @@ std::string uhd::get_tmp_path(void){
 
     //try the stdio define if available
     #ifdef P_tmpdir
-    return P_tmpdir;
-    #else
+    if (P_tmpdir != NULL) return P_tmpdir;
+    #endif
 
     //try unix environment variables
     tmp_path = std::getenv("TMPDIR");
@@ -124,7 +124,6 @@ std::string uhd::get_tmp_path(void){
 
     //give up and use the unix default
     return "/tmp";
-    #endif
 }
 
 std::string uhd::get_app_path(void){
diff --git a/host/tests/sph_recv_test.cpp b/host/tests/sph_recv_test.cpp
index 316e247..9339a97 100644
--- a/host/tests/sph_recv_test.cpp
+++ b/host/tests/sph_recv_test.cpp
@@ -395,7 +395,7 @@ BOOST_AUTO_TEST_CASE(test_sph_recv_multi_channel_normal){
 
     //check the received packets
     size_t num_accum_samps = 0;
-    std::complex<float> mem[NUM_SAMPS_PER_BUFF*NCHANNELS];
+    std::vector<std::complex<float> > mem(NUM_SAMPS_PER_BUFF*NCHANNELS);
     std::vector<std::complex<float> *> buffs(NCHANNELS);
     for (size_t ch = 0; ch < NCHANNELS; ch++){
         buffs[ch] = &mem[ch*NUM_SAMPS_PER_BUFF];
@@ -481,7 +481,7 @@ BOOST_AUTO_TEST_CASE(test_sph_recv_multi_channel_sequence_error){
 
     //check the received packets
     size_t num_accum_samps = 0;
-    std::complex<float> mem[NUM_SAMPS_PER_BUFF*NCHANNELS];
+    std::vector<std::complex<float> > mem(NUM_SAMPS_PER_BUFF*NCHANNELS);
     std::vector<std::complex<float> *> buffs(NCHANNELS);
     for (size_t ch = 0; ch < NCHANNELS; ch++){
         buffs[ch] = &mem[ch*NUM_SAMPS_PER_BUFF];
@@ -574,7 +574,7 @@ BOOST_AUTO_TEST_CASE(test_sph_recv_multi_channel_time_error){
 
     //check the received packets
     size_t num_accum_samps = 0;
-    std::complex<float> mem[NUM_SAMPS_PER_BUFF*NCHANNELS];
+    std::vector<std::complex<float> > mem(NUM_SAMPS_PER_BUFF*NCHANNELS);
     std::vector<std::complex<float> *> buffs(NCHANNELS);
     for (size_t ch = 0; ch < NCHANNELS; ch++){
         buffs[ch] = &mem[ch*NUM_SAMPS_PER_BUFF];
@@ -659,7 +659,7 @@ BOOST_AUTO_TEST_CASE(test_sph_recv_multi_channel_fragment){
 
     //check the received packets
     size_t num_accum_samps = 0;
-    std::complex<float> mem[NUM_SAMPS_PER_BUFF*NCHANNELS];
+    std::vector<std::complex<float> > mem(NUM_SAMPS_PER_BUFF*NCHANNELS);
     std::vector<std::complex<float> *> buffs(NCHANNELS);
     for (size_t ch = 0; ch < NCHANNELS; ch++){
         buffs[ch] = &mem[ch*NUM_SAMPS_PER_BUFF];
diff --git a/host/tests/time_spec_test.cpp b/host/tests/time_spec_test.cpp
index c9b9652..37a039c 100644
--- a/host/tests/time_spec_test.cpp
+++ b/host/tests/time_spec_test.cpp
@@ -117,7 +117,6 @@ BOOST_AUTO_TEST_CASE(test_time_error_irrational_rate)
     const uhd::time_spec_t ts = uhd::time_spec_t::from_ticks(tick_in, rate);
     const long long tick_out = ts.to_ticks(rate);
     const long long err = tick_in - tick_out;
-    std::streamsize precision = std::cout.precision();
 
     std::cout << std::setprecision(18);
     std::cout << "time ............ " << ts.get_real_secs() << std::endl;
@@ -125,7 +124,6 @@ BOOST_AUTO_TEST_CASE(test_time_error_irrational_rate)
     std::cout << "tick out ........ " << tick_out << std::endl;
     std::cout << "tick error ...... " << err << std::endl;
     std::cout << std::endl;
-    std::cout.precision(precision);
 
     BOOST_CHECK_EQUAL(err, (long long)(0));
 }
diff --git a/host/utils/b2xx_fx3_utils.cpp b/host/utils/b2xx_fx3_utils.cpp
index adacff9..c182548 100644
--- a/host/utils/b2xx_fx3_utils.cpp
+++ b/host/utils/b2xx_fx3_utils.cpp
@@ -209,9 +209,7 @@ boost::int32_t main(boost::int32_t argc, char *argv[]) {
     po::notify(vm);
 
     if (vm.count("help")){
-        try {
-            std::cout << boost::format("B2xx Utility Program %s") % visible << std::endl;
-        } catch(...) {}
+        std::cout << boost::format("B2xx Utility Program %s") % visible << std::endl;
         return ~0;
     } else if (vm.count("reset-usb")) {
         return reset_usb();
@@ -222,15 +220,10 @@ boost::int32_t main(boost::int32_t argc, char *argv[]) {
 
     vid = B200_VENDOR_ID;   // Default
     pid = B200_PRODUCT_ID;  // Default
-    try {
-        if (vm.count("vid"))
-            vid = atoh(vid_str);
-        if (vm.count("pid"))
-            pid = atoh(pid_str);
-    } catch (std::exception &e) {
-        std::cerr << "Exception while parsing VID and PID: " << e.what() << std:: endl;
-        return ~0;
-    }
+    if (vm.count("vid"))
+        vid = atoh(vid_str);
+    if (vm.count("pid"))
+        pid = atoh(pid_str);
 
     // open the device
     handle = open_device(vid, pid);
@@ -250,11 +243,7 @@ boost::int32_t main(boost::int32_t argc, char *argv[]) {
         std::cout << "Overwriting existing firmware" << std::endl;
 
         // reset the device
-        try {
-            b200->reset_fx3();
-        } catch (std::exception &e) {
-            std::cerr << "Exception while reseting FX3: " << e.what() << std::endl;
-        }
+        b200->reset_fx3();
 
         // re-open device
         b200.reset();
@@ -275,24 +264,19 @@ boost::int32_t main(boost::int32_t argc, char *argv[]) {
 
         if (fw_file.empty())
             fw_file = uhd::find_image_path(B200_FW_FILE_NAME);
-
+            
         if(fw_file.empty()) {
             std::cerr << "Firmware image not found!" << std::endl;
             return -1;
         }
-
+        
         if(!(fs::exists(fw_file))) {
             std::cerr << "Invalid filepath: " << fw_file << std::endl;
             return -1;
         }
 
         // load firmware
-        try {
-            b200->load_firmware(fw_file);
-        } catch (std::exception &e) {
-            std::cerr << "Exception while loading firmware: " << e.what() << std::endl;
-            return ~0;
-        }
+        b200->load_firmware(fw_file);
 
         // re-open device
         b200.reset();
@@ -419,7 +403,7 @@ boost::int32_t main(boost::int32_t argc, char *argv[]) {
         try {
             b200->reset_fx3();
         } catch (const std::exception &e) {
-            std::cerr << "Exception while resetting device: " << e.what() << std::endl;
+            std::cerr << "Exceptions while resetting device: " << e.what() << std::endl;
             return -1;
         }
 
@@ -477,9 +461,7 @@ boost::int32_t main(boost::int32_t argc, char *argv[]) {
             << std::endl;
 
     } else {
-        try {
-            std::cout << boost::format("B2xx Utility Program %s") % visible << std::endl;
-        } catch(...) {}
+        std::cout << boost::format("B2xx Utility Program %s") % visible << std::endl;
         return ~0;
     }
 
-- 
1.7.10.4

