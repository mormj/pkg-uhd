From b2167e1ae42cb4afc1d474723028e50fa8aef48b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marcus=20M=C3=BCller?= <marcus.mueller@ettus.com>
Date: Sat, 4 Jun 2016 00:17:53 +0200
Subject: [PATCH 09/29] added Wireshark Dissector for Octoclock packets

---
 tools/octoclock-dissector/.gitignore               |   2 +
 tools/octoclock-dissector/CMakeLists.txt           |  96 +++++++
 .../cmake/Modules/FindGLIB2.cmake                  | 238 ++++++++++++++++
 .../cmake/Modules/FindWireshark.cmake              |  28 ++
 tools/octoclock-dissector/make-dissector-reg.py    | 305 +++++++++++++++++++++
 tools/octoclock-dissector/moduleinfo.h             |   9 +
 tools/octoclock-dissector/packet-octoclock.c       | 212 ++++++++++++++
 tools/octoclock-dissector/plugin.rc.in             |  34 +++
 8 files changed, 924 insertions(+)
 create mode 100644 tools/octoclock-dissector/.gitignore
 create mode 100644 tools/octoclock-dissector/CMakeLists.txt
 create mode 100644 tools/octoclock-dissector/cmake/Modules/FindGLIB2.cmake
 create mode 100644 tools/octoclock-dissector/cmake/Modules/FindWireshark.cmake
 create mode 100755 tools/octoclock-dissector/make-dissector-reg.py
 create mode 100644 tools/octoclock-dissector/moduleinfo.h
 create mode 100644 tools/octoclock-dissector/packet-octoclock.c
 create mode 100644 tools/octoclock-dissector/plugin.rc.in

diff --git a/tools/octoclock-dissector/.gitignore b/tools/octoclock-dissector/.gitignore
new file mode 100644
index 0000000..0187b3d
--- /dev/null
+++ b/tools/octoclock-dissector/.gitignore
@@ -0,0 +1,2 @@
+build/
+*~
diff --git a/tools/octoclock-dissector/CMakeLists.txt b/tools/octoclock-dissector/CMakeLists.txt
new file mode 100644
index 0000000..7b2b7ba
--- /dev/null
+++ b/tools/octoclock-dissector/CMakeLists.txt
@@ -0,0 +1,96 @@
+# Copyright 2010-2016 Ettus Research LLC
+# 
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+
+
+########################################################################
+# Project setup
+########################################################################
+cmake_minimum_required(VERSION 2.6)
+project(octoclock-dissector C)
+set(octoclock-dissector_VERSION_MAJOR 0)
+set(octoclock-dissector_VERSION_MINOR 7)
+enable_testing()
+
+#select the release build type by default to get optimization flags
+if(NOT CMAKE_BUILD_TYPE)
+   set(CMAKE_BUILD_TYPE "Release")
+   message(STATUS "Build type not specified: defaulting to release.")
+endif(NOT CMAKE_BUILD_TYPE)
+set(CMAKE_BUILD_TYPE ${CMAKE_BUILD_TYPE} CACHE STRING "")
+
+list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/Modules)
+
+########################################################################
+# Compiler specific setup
+########################################################################
+#if(CMAKE_COMPILER_IS_GNUC AND NOT WIN32)
+#    #http://gcc.gnu.org/wiki/Visibility
+#    add_definitions(-fvisibility=visible)
+#endif()
+
+find_package(GLIB2)
+if(NOT GLIB2_FOUND)
+    message(FATAL_ERROR "Glib not found")
+endif()
+
+find_package(Wireshark)
+if(NOT WIRESHARK_FOUND)
+    message(FATAL_ERROR "Wireshark dev package not found")
+endif()
+
+
+########################################################################
+# Setup the include and linker paths
+########################################################################
+include_directories(
+    ${CMAKE_SOURCE_DIR}
+    ${GLIB2_INCLUDE_DIRS}
+    ${WIRESHARK_INCLUDE_DIRS}
+)
+
+#link_directories(
+#    ${Boost_LIBRARY_DIRS}
+#)
+set(CMAKE_INSTALL_LIBDIR ~/.wireshark)
+
+# Set component parameters
+set(octoclock_DISSECTOR_INCLUDE_DIRS ${CMAKE_SOURCE_DIR} CACHE INTERNAL "" FORCE)
+
+set(octoclock_PLUGIN_SRC ${CMAKE_SOURCE_DIR}/packet-octoclock.c)
+
+set(PLUGIN_C_GENERATOR ${CMAKE_SOURCE_DIR}/make-dissector-reg.py)
+set(PLUGIN_C plugin.c)
+
+add_custom_command(
+        OUTPUT ${PLUGIN_C}
+        DEPENDS ${octoclock_PLUGIN_SRC}
+        COMMAND ${PLUGIN_C_GENERATOR} ${CMAKE_SOURCE_DIR} plugin ${octoclock_PLUGIN_SRC}
+        COMMENT "Generating ${PLUGIN_C}"
+)
+
+add_library(octoclock-plugin MODULE
+    ${PLUGIN_C}
+    moduleinfo.h
+    ${octoclock_PLUGIN_SRC}
+)
+set_target_properties(octoclock-plugin PROPERTIES PREFIX "")
+set_target_properties(octoclock-plugin PROPERTIES LINK_FLAGS "${WS_LINK_FLAGS}")
+target_link_libraries(octoclock-plugin wireshark)
+
+install(TARGETS octoclock-plugin
+	LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/plugins NAMELINK_SKIP
+)
diff --git a/tools/octoclock-dissector/cmake/Modules/FindGLIB2.cmake b/tools/octoclock-dissector/cmake/Modules/FindGLIB2.cmake
new file mode 100644
index 0000000..ae7badd
--- /dev/null
+++ b/tools/octoclock-dissector/cmake/Modules/FindGLIB2.cmake
@@ -0,0 +1,238 @@
+#
+# $Id: FindGLIB2.cmake 34248 2010-09-25 15:38:12Z jmayer $
+#
+# - Try to find GLib2
+# Once done this will define
+#
+#  GLIB2_FOUND - system has GLib2
+#  GLIB2_INCLUDE_DIRS - the GLib2 include directory
+#  GLIB2_LIBRARIES - Link these to use GLib2
+#
+#  HAVE_GLIB_GREGEX_H  glib has gregex.h header and 
+#                      supports g_regex_match_simple
+#
+#  Copyright (c) 2006 Andreas Schneider <mail@cynapses.org>
+#  Copyright (c) 2006 Philippe Bernery <philippe.bernery@gmail.com>
+#  Copyright (c) 2007 Daniel Gollub <gollub@b1-systems.de>
+#  Copyright (c) 2007 Alban Browaeys <prahal@yahoo.com>
+#  Copyright (c) 2008 Michael Bell <michael.bell@web.de>
+#  Copyright (c) 2008-2009 Bjoern Ricks <bjoern.ricks@googlemail.com>
+#
+#  Redistribution and use is allowed according to the terms of the New
+#  BSD license.
+#  For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+#
+
+
+IF (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIRS )
+  # in cache already
+  SET(GLIB2_FOUND TRUE)
+ELSE (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIRS )
+
+  INCLUDE(FindPkgConfig)
+
+  ## Glib
+  IF ( GLIB2_FIND_REQUIRED )
+    SET( _pkgconfig_REQUIRED "REQUIRED" )
+  ELSE ( GLIB2_FIND_REQUIRED )
+    SET( _pkgconfig_REQUIRED "" )
+  ENDIF ( GLIB2_FIND_REQUIRED )
+
+  IF ( GLIB2_MIN_VERSION )
+    PKG_SEARCH_MODULE( GLIB2 ${_pkgconfig_REQUIRED} glib-2.0>=${GLIB2_MIN_VERSION} )
+  ELSE ( GLIB2_MIN_VERSION )
+    PKG_SEARCH_MODULE( GLIB2 ${_pkgconfig_REQUIRED} glib-2.0 )
+  ENDIF ( GLIB2_MIN_VERSION )
+  IF ( PKG_CONFIG_FOUND )
+    IF ( GLIB2_FOUND )
+      SET ( GLIB2_CORE_FOUND TRUE )
+    ELSE ( GLIB2_FOUND )
+      SET ( GLIB2_CORE_FOUND FALSE )
+    ENDIF ( GLIB2_FOUND )
+  ENDIF ( PKG_CONFIG_FOUND )
+
+  # Look for glib2 include dir and libraries w/o pkgconfig
+  IF ( NOT GLIB2_FOUND AND NOT PKG_CONFIG_FOUND )
+    FIND_PATH(
+      _glibconfig_include_DIR
+    NAMES
+      glibconfig.h
+    PATHS
+      /opt/gnome/lib64
+      /opt/gnome/lib
+      /opt/lib/
+      /opt/local/lib
+      /sw/lib/
+      /usr/lib64
+      /usr/lib
+      /usr/local/include
+      ${CMAKE_LIBRARY_PATH}
+    PATH_SUFFIXES
+      glib-2.0/include
+    )
+
+    FIND_PATH(
+      _glib2_include_DIR
+    NAMES
+      glib.h
+    PATHS
+      /opt/gnome/include
+      /opt/local/include
+      /sw/include
+      /usr/include
+      /usr/local/include
+    PATH_SUFFIXES
+      glib-2.0
+    )
+
+    #MESSAGE(STATUS "Glib headers: ${_glib2_include_DIR}")
+
+    FIND_LIBRARY(
+      _glib2_link_DIR
+    NAMES
+      glib-2.0
+      glib
+    PATHS
+      /opt/gnome/lib
+      /opt/local/lib
+      /sw/lib
+      /usr/lib
+      /usr/local/lib
+    )
+    IF ( _glib2_include_DIR AND _glib2_link_DIR )
+        SET ( _glib2_FOUND TRUE )
+    ENDIF ( _glib2_include_DIR AND _glib2_link_DIR )
+
+
+    IF ( _glib2_FOUND )
+        SET ( GLIB2_INCLUDE_DIRS ${_glib2_include_DIR} ${_glibconfig_include_DIR} )
+        SET ( GLIB2_LIBRARIES ${_glib2_link_DIR} )
+        SET ( GLIB2_CORE_FOUND TRUE )
+    ELSE ( _glib2_FOUND )
+        SET ( GLIB2_CORE_FOUND FALSE )
+    ENDIF ( _glib2_FOUND )
+
+    # Handle dependencies
+    # libintl
+    IF ( NOT LIBINTL_FOUND )
+      FIND_PATH(LIBINTL_INCLUDE_DIR
+      NAMES
+        libintl.h
+      PATHS
+        /opt/gnome/include
+        /opt/local/include
+        /sw/include
+        /usr/include
+        /usr/local/include
+      )
+
+      FIND_LIBRARY(LIBINTL_LIBRARY
+      NAMES
+        intl
+      PATHS
+        /opt/gnome/lib
+        /opt/local/lib
+        /sw/lib
+        /usr/local/lib
+        /usr/lib
+      )
+
+      IF (LIBINTL_LIBRARY AND LIBINTL_INCLUDE_DIR)
+        SET (LIBINTL_FOUND TRUE)
+      ENDIF (LIBINTL_LIBRARY AND LIBINTL_INCLUDE_DIR)
+    ENDIF ( NOT LIBINTL_FOUND )
+
+    # libiconv
+    IF ( NOT LIBICONV_FOUND )
+      FIND_PATH(LIBICONV_INCLUDE_DIR
+      NAMES
+        iconv.h
+      PATHS
+        /opt/gnome/include
+        /opt/local/include
+        /opt/local/include
+        /sw/include
+        /sw/include
+        /usr/local/include
+        /usr/include
+      PATH_SUFFIXES
+        glib-2.0
+      )
+
+      FIND_LIBRARY(LIBICONV_LIBRARY
+      NAMES
+        iconv
+      PATHS
+        /opt/gnome/lib
+        /opt/local/lib
+        /sw/lib
+        /usr/lib
+        /usr/local/lib
+      )
+
+      IF (LIBICONV_LIBRARY AND LIBICONV_INCLUDE_DIR)
+        SET (LIBICONV_FOUND TRUE)
+      ENDIF (LIBICONV_LIBRARY AND LIBICONV_INCLUDE_DIR)
+    ENDIF ( NOT LIBICONV_FOUND )
+
+    IF (LIBINTL_FOUND)
+      SET (GLIB2_LIBRARIES ${GLIB2_LIBRARIES} ${LIBINTL_LIBRARY})
+      SET (GLIB2_INCLUDE_DIRS ${GLIB2_INCLUDE_DIRS} ${LIBINTL_INCLUDE_DIR})
+    ENDIF (LIBINTL_FOUND)
+
+    IF (LIBICONV_FOUND)
+      SET (GLIB2_LIBRARIES ${GLIB2_LIBRARIES} ${LIBICONV_LIBRARY})
+      SET (GLIB2_INCLUDE_DIRS ${GLIB2_INCLUDE_DIRS} ${LIBICONV_INCLUDE_DIR})
+    ENDIF (LIBICONV_FOUND)
+
+  ENDIF ( NOT GLIB2_FOUND AND NOT PKG_CONFIG_FOUND )
+  ##
+
+  IF (GLIB2_CORE_FOUND AND GLIB2_INCLUDE_DIRS AND GLIB2_LIBRARIES)
+    SET (GLIB2_FOUND TRUE)
+  ENDIF (GLIB2_CORE_FOUND AND GLIB2_INCLUDE_DIRS AND GLIB2_LIBRARIES)
+
+  IF (GLIB2_FOUND)
+    IF (NOT GLIB2_FIND_QUIETLY)
+      MESSAGE (STATUS "Found GLib2: ${GLIB2_LIBRARIES} ${GLIB2_INCLUDE_DIRS}")
+    ENDIF (NOT GLIB2_FIND_QUIETLY)
+  ELSE (GLIB2_FOUND)
+    IF (GLIB2_FIND_REQUIRED)
+      MESSAGE (SEND_ERROR "Could not find GLib2")
+    ENDIF (GLIB2_FIND_REQUIRED)
+  ENDIF (GLIB2_FOUND)
+
+  # show the GLIB2_INCLUDE_DIRS and GLIB2_LIBRARIES variables only in the advanced view
+  MARK_AS_ADVANCED(GLIB2_INCLUDE_DIRS GLIB2_LIBRARIES)
+  MARK_AS_ADVANCED(LIBICONV_INCLUDE_DIR LIBICONV_LIBRARY)
+  MARK_AS_ADVANCED(LIBINTL_INCLUDE_DIR LIBINTL_LIBRARY)
+
+ENDIF (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIRS)
+
+IF ( WIN32 )
+    # include libiconv for win32
+    IF ( NOT LIBICONV_FOUND )
+      FIND_PATH(LIBICONV_INCLUDE_DIR iconv.h PATH_SUFFIXES glib-2.0)
+
+      FIND_LIBRARY(LIBICONV_LIBRARY NAMES iconv)
+
+      IF (LIBICONV_LIBRARY AND LIBICONV_INCLUDE_DIR)
+        SET (LIBICONV_FOUND TRUE)
+      ENDIF (LIBICONV_LIBRARY AND LIBICONV_INCLUDE_DIR)
+    ENDIF ( NOT LIBICONV_FOUND )
+    IF (LIBICONV_FOUND)
+      SET (GLIB2_LIBRARIES ${GLIB2_LIBRARIES} ${LIBICONV_LIBRARY})
+      SET (GLIB2_INCLUDE_DIRS ${GLIB2_INCLUDE_DIRS} ${LIBICONV_INCLUDE_DIR})
+    ENDIF (LIBICONV_FOUND)
+ENDIF ( WIN32 )
+
+IF ( GLIB2_FOUND )
+	# Check if system has a newer version of glib
+	# which supports g_regex_match_simple
+	INCLUDE( CheckIncludeFiles )
+	SET( CMAKE_REQUIRED_INCLUDES ${GLIB2_INCLUDE_DIRS} )
+	CHECK_INCLUDE_FILES ( glib/gregex.h HAVE_GLIB_GREGEX_H )
+	CHECK_INCLUDE_FILES ( glib/gchecksum.h HAVE_GLIB_GCHECKSUM_H )
+	# Reset CMAKE_REQUIRED_INCLUDES
+	SET( CMAKE_REQUIRED_INCLUDES "" )
+ENDIF( GLIB2_FOUND )
diff --git a/tools/octoclock-dissector/cmake/Modules/FindWireshark.cmake b/tools/octoclock-dissector/cmake/Modules/FindWireshark.cmake
new file mode 100644
index 0000000..2762012
--- /dev/null
+++ b/tools/octoclock-dissector/cmake/Modules/FindWireshark.cmake
@@ -0,0 +1,28 @@
+#
+# Try to find the wireshark library and its includes
+#
+# This snippet sets the following variables:
+#  WIRESHARK_FOUND             True if wireshark library got found
+#  WIRESHARK_INCLUDE_DIRS      Location of the wireshark headers 
+#  WIRESHARK_LIBRARIES         List of libraries to use wireshark
+#
+#  Copyright (c) 2011 Reinhold Kainhofer <reinhold@kainhofer.com>
+#
+#  Redistribution and use is allowed according to the terms of the New
+#  BSD license.
+#  For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+#
+
+# wireshark does not install its library with pkg-config information,
+# so we need to manually find the libraries and headers
+
+FIND_PATH( WIRESHARK_INCLUDE_DIRS epan/column.h PATH_SUFFIXES wireshark )
+FIND_LIBRARY( WIRESHARK_LIBRARIES wireshark )
+
+# Report results
+IF ( WIRESHARK_LIBRARIES AND WIRESHARK_INCLUDE_DIRS )
+  SET( WIRESHARK_FOUND 1 )
+ELSE ( WIRESHARK_LIBRARIES AND WIRESHARK_INCLUDE_DIRS )
+  MESSAGE( SEND_ERROR "Could NOT find the wireshark library and headers" )
+ENDIF ( WIRESHARK_LIBRARIES AND WIRESHARK_INCLUDE_DIRS )
+
diff --git a/tools/octoclock-dissector/make-dissector-reg.py b/tools/octoclock-dissector/make-dissector-reg.py
new file mode 100755
index 0000000..4497290
--- /dev/null
+++ b/tools/octoclock-dissector/make-dissector-reg.py
@@ -0,0 +1,305 @@
+#!/usr/bin/env python
+#
+# Looks for registration routines in the protocol dissectors,
+# and assembles C code to call all the routines.
+#
+# This is a Python version of the make-reg-dotc shell script.
+# Running the shell script on Win32 is very very slow because of
+# all the process-launching that goes on --- multiple greps and
+# seds for each input file.  I wrote this python version so that
+# less processes would have to be started.
+#
+# $Id: make-dissector-reg.py 30447 2009-10-09 20:47:18Z krj $
+
+import os
+import sys
+import re
+import pickle
+from stat import *
+
+VERSION_KEY = '_VERSION'
+CUR_VERSION = '$Id: make-dissector-reg.py 30447 2009-10-09 20:47:18Z krj $'
+
+#
+# The first argument is the directory in which the source files live.
+#
+srcdir = sys.argv[1]
+
+#
+# The second argument is either "plugin" or "dissectors"; if it's
+# "plugin", we build a plugin.c for a plugin, and if it's
+# "dissectors", we build a register.c for libwireshark.
+#
+registertype = sys.argv[2]
+if registertype == "plugin" or registertype == "plugin_wtap":
+	tmp_filename = "plugin.c-tmp"
+	final_filename = "plugin.c"
+	cache_filename = None
+	preamble = """\
+/*
+ * Do not modify this file.
+ *
+ * It is created automatically by Makefile or Makefile.nmake.
+ */
+"""
+elif registertype == "dissectors":
+	tmp_filename = "register.c-tmp"
+	final_filename = "register.c"
+	cache_filename = "register-cache.pkl"
+	preamble = """\
+/*
+ * Do not modify this file.
+ *
+ * It is created automatically by the "register.c" target in
+ * epan/dissectors/Makefile or Makefile.nmake using information in
+ * epan/dissectors/register-cache.pkl.
+ *
+ * You can force this file to be regenerated completely by deleting
+ * it along with epan/dissectors/register-cache.pkl.
+ */
+"""
+else:
+	print "Unknown output type '%s'" % registertype
+	sys.exit(1)
+
+
+#
+# All subsequent arguments are the files to scan.
+#
+files = sys.argv[3:]
+
+# Create the proper list of filenames
+filenames = []
+for file in files:
+	if os.path.isfile(file):
+		filenames.append(file)
+	else:
+		filenames.append(os.path.join(srcdir, file))
+
+if len(filenames) < 1:
+	print "No files found"
+	sys.exit(1)
+
+
+# Look through all files, applying the regex to each line.
+# If the pattern matches, save the "symbol" section to the
+# appropriate array.
+regs = {
+	'proto_reg': [],
+	'handoff_reg': [],
+	'wtap_register': [],
+	}
+
+# For those that don't know Python, r"" indicates a raw string,
+# devoid of Python escapes.
+proto_regex0 = r"^(?P<symbol>proto_register_[_A-Za-z0-9]+)\s*\([^;]+$"
+proto_regex1 = r"void\s+(?P<symbol>proto_register_[_A-Za-z0-9]+)\s*\([^;]+$"
+
+handoff_regex0 = r"^(?P<symbol>proto_reg_handoff_[_A-Za-z0-9]+)\s*\([^;]+$"
+handoff_regex1 = r"void\s+(?P<symbol>proto_reg_handoff_[_A-Za-z0-9]+)\s*\([^;]+$"
+
+wtap_reg_regex0 = r"^(?P<symbol>wtap_register_[_A-Za-z0-9]+)\s*\([^;]+$"
+wtap_reg_regex1 = r"void\s+(?P<symbol>wtap_register_[_A-Za-z0-9]+)\s*\([^;]+$"
+
+# This table drives the pattern-matching and symbol-harvesting
+patterns = [
+	( 'proto_reg', re.compile(proto_regex0) ),
+	( 'proto_reg', re.compile(proto_regex1) ),
+	( 'handoff_reg', re.compile(handoff_regex0) ),
+	( 'handoff_reg', re.compile(handoff_regex1) ),
+	( 'wtap_register', re.compile(wtap_reg_regex0) ),
+	( 'wtap_register', re.compile(wtap_reg_regex1) ),
+	]
+
+# Open our registration symbol cache
+cache = None
+if cache_filename:
+	try:
+		cache_file = open(cache_filename, 'rb')
+		cache = pickle.load(cache_file)
+		cache_file.close()
+		if not cache.has_key(VERSION_KEY) or cache[VERSION_KEY] != CUR_VERSION:
+			cache = {VERSION_KEY: CUR_VERSION}
+	except:
+		cache = {VERSION_KEY: CUR_VERSION}
+
+# Grep
+for filename in filenames:
+	file = open(filename)
+	cur_mtime = os.fstat(file.fileno())[ST_MTIME]
+	if cache and cache.has_key(filename):
+		cdict = cache[filename]
+		if cur_mtime == cdict['mtime']:
+#			print "Pulling %s from cache" % (filename)
+			regs['proto_reg'].extend(cdict['proto_reg'])
+			regs['handoff_reg'].extend(cdict['handoff_reg'])
+			regs['wtap_register'].extend(cdict['wtap_register'])
+			file.close()
+			continue
+	# We don't have a cache entry
+	if cache is not None:
+		cache[filename] = {
+			'mtime': cur_mtime,
+			'proto_reg': [],
+			'handoff_reg': [],
+			'wtap_register': [],
+			}
+#	print "Searching %s" % (filename)
+	for line in file.readlines():
+		for action in patterns:
+			regex = action[1]
+			match = regex.search(line)
+			if match:
+				symbol = match.group("symbol")
+				sym_type = action[0]
+				regs[sym_type].append(symbol)
+				if cache is not None:
+#					print "Caching %s for %s: %s" % (sym_type, filename, symbol)
+					cache[filename][sym_type].append(symbol)
+	file.close()
+
+if cache is not None and cache_filename is not None:
+	cache_file = open(cache_filename, 'wb')
+	pickle.dump(cache, cache_file)
+	cache_file.close()
+
+# Make sure we actually processed something
+if len(regs['proto_reg']) < 1:
+	print "No protocol registrations found"
+	sys.exit(1)
+
+# Sort the lists to make them pretty
+regs['proto_reg'].sort()
+regs['handoff_reg'].sort()
+regs['wtap_register'].sort()
+
+reg_code = open(tmp_filename, "w")
+
+reg_code.write(preamble)
+
+# Make the routine to register all protocols
+if registertype == "plugin" or registertype == "plugin_wtap":
+	reg_code.write("""
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <gmodule.h>
+
+#include "moduleinfo.h"
+
+#ifndef ENABLE_STATIC
+G_MODULE_EXPORT const gchar version[] = VERSION;
+
+/* Start the functions we need for the plugin stuff */
+
+G_MODULE_EXPORT void
+plugin_register (void)
+{
+""");
+else:
+	reg_code.write("""
+#include "register.h"
+void
+register_all_protocols(register_cb cb, gpointer client_data)
+{
+""");
+
+for symbol in regs['proto_reg']:
+	if registertype == "plugin" or registertype == "plugin_wtap":
+		line = "  {extern void %s (void); %s ();}\n" % (symbol, symbol)
+	else:
+		line = "  {extern void %s (void); if(cb) (*cb)(RA_REGISTER, \"%s\", client_data); %s ();}\n" % (symbol, symbol, symbol)
+	reg_code.write(line)
+
+reg_code.write("}\n")
+
+
+# Make the routine to register all protocol handoffs
+if registertype == "plugin" or registertype == "plugin_wtap":
+	reg_code.write("""
+G_MODULE_EXPORT void
+plugin_reg_handoff(void)
+{
+""");
+else:
+	reg_code.write("""
+void
+register_all_protocol_handoffs(register_cb cb, gpointer client_data)
+{
+""");
+
+for symbol in regs['handoff_reg']:
+	if registertype == "plugin" or registertype == "plugin_wtap":
+		line = "  {extern void %s (void); %s ();}\n" % (symbol, symbol)
+	else:
+		line = "  {extern void %s (void); if(cb) (*cb)(RA_HANDOFF, \"%s\", client_data); %s ();}\n" % (symbol, symbol, symbol)
+	reg_code.write(line)
+
+reg_code.write("}\n")
+
+if registertype == "plugin":
+	reg_code.write("#endif\n");
+elif registertype == "plugin_wtap":
+	reg_code.write("""
+G_MODULE_EXPORT void
+register_wtap_module(void)
+{
+""");
+
+	for symbol in regs['wtap_register']:
+		line = "  {extern void %s (void); %s ();}\n" % (symbol, symbol)
+		reg_code.write(line)
+
+	reg_code.write("}\n");
+        reg_code.write("#endif\n");
+else:
+	reg_code.write("""
+static gulong proto_reg_count(void)
+{
+""");
+
+	line = "  return %d;\n" % len(regs['proto_reg'])
+	reg_code.write(line)
+
+	reg_code.write("""
+}
+""");
+	reg_code.write("""
+static gulong handoff_reg_count(void)
+{
+""");
+
+	line = "  return %d;\n" % len(regs['handoff_reg'])
+	reg_code.write(line)
+
+	reg_code.write("""
+}
+""");
+	reg_code.write("""
+gulong register_count(void)
+{
+""");
+
+	line = "  return proto_reg_count() + handoff_reg_count();"
+	reg_code.write(line)
+
+	reg_code.write("""
+}\n
+""");
+
+
+# Close the file
+reg_code.close()
+
+# Remove the old final_file if it exists.
+try:
+	os.stat(final_filename)
+	os.remove(final_filename)
+except OSError:
+	pass
+
+# Move from tmp file to final file
+os.rename(tmp_filename, final_filename)
+
+
diff --git a/tools/octoclock-dissector/moduleinfo.h b/tools/octoclock-dissector/moduleinfo.h
new file mode 100644
index 0000000..494d0a9
--- /dev/null
+++ b/tools/octoclock-dissector/moduleinfo.h
@@ -0,0 +1,9 @@
+#ifdef PACKAGE
+#undef PACKAGE
+#endif
+#define PACKAGE "octo"
+#ifdef VERSION
+#undef VERSION
+#endif
+#define VERSION "0.0.0.1"
+
diff --git a/tools/octoclock-dissector/packet-octoclock.c b/tools/octoclock-dissector/packet-octoclock.c
new file mode 100644
index 0000000..453c325
--- /dev/null
+++ b/tools/octoclock-dissector/packet-octoclock.c
@@ -0,0 +1,212 @@
+/*
+ * Dissector for Ettus Octoclock packets
+ *
+ * Copyright 2016 Ettus Research
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <glib.h>
+#include <epan/packet.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stddef.h>
+
+#include "../../host/lib/usrp_clock/octoclock/common.h"
+
+#define LOG_HEADER  "[Octoclock] "
+#define size_mem(t,m) sizeof(((t*)0)->m)
+#define packet_elem_size(m) (size_mem(octoclock_packet_t,m))
+#define packet_offset(m) (offsetof(octoclock_packet_t, m))
+const unsigned int OCTOCLOCK_PORT = OCTOCLOCK_UDP_CTRL_PORT;
+
+static int 	proto_octo 		= -1;
+static int 	hf_octo_proto_version 	= -1;
+static int 	hf_octo_proto_sequence 	= -1;
+static int 	hf_octo_proto_code 	= -1;
+static int 	hf_octo_proto_poolsize 	= -1;
+static int 	hf_octo_proto_data 	= -1;
+static int 	hf_octo_proto_payload 	= -1;
+static int 	hf_octo_proto_len 	= -1;
+static gint 	ett_octo 		= -1;
+static const value_string packetcodes[] = {
+	{1, "OCTOCLOCK_QUERY_CMD"},
+	{2, "OCTOCLOCK_QUERY_ACK"},
+	{3, "SEND_EEPROM_CMD"},
+	{4, "SEND_EEPROM_ACK"},
+	{5, "BURN_EEPROM_CMD"},
+	{6, "BURN_EEPROM_SUCCESS_ACK"},
+	{7, "BURN_EEPROM_FAILURE_ACK"},
+	{8, "CLEAR_EEPROM_CMD"},
+	{9, "CLEAR_EEPROM_ACK"},
+	{10, "SEND_STATE_CMD"},
+	{11, "SEND_STATE_ACK"},
+	{12, "RESET_CMD"},
+	{13, "RESET_ACK"},
+	{14, "HOST_SEND_TO_GPSDO_CMD"},
+	{15, "HOST_SEND_TO_GPSDO_ACK"},
+	{16, "SEND_POOLSIZE_CMD"},
+	{17, "SEND_POOLSIZE_ACK"},
+	{18, "SEND_CACHE_STATE_CMD"},
+	{19, "SEND_CACHE_STATE_ACK"},
+	{20, "SEND_GPSDO_CACHE_CMD"},
+	{21, "SEND_GPSDO_CACHE_ACK"},
+	{22, "PREPARE_FW_BURN_CMD"},
+	{23, "FW_BURN_READY_ACK"},
+	{24, "FILE_TRANSFER_CMD"},
+	{25, "FILE_TRANSFER_ACK"},
+	{26, "READ_FW_CMD"},
+	{27, "READ_FW_ACK"},
+	{28, "FINALIZE_BURNING_CMD"},
+	{29, "FINALIZE_BURNING_ACK"},
+	{ 0, NULL }
+};
+/* Forward-declare the dissector functions */
+void proto_register_octo(void);
+void proto_reg_handoff_octo(void);
+static void dissect_octo(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+
+static void dissect_octo(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "OCTO");
+	col_clear(pinfo->cinfo, COL_INFO);
+	proto_item *ti = proto_tree_add_item(tree, proto_octo, tvb, 0, -1, ENC_NA);
+	proto_tree *octo_tree = proto_item_add_subtree(ti, ett_octo);
+	proto_tree_add_item(octo_tree,
+			hf_octo_proto_version,
+			tvb,
+			packet_offset(proto_ver),
+			packet_elem_size(proto_ver),
+			ENC_LITTLE_ENDIAN);
+	guint32 rev = tvb_get_letohl(tvb, packet_offset(proto_ver));
+	if(rev==3)
+	{
+		proto_tree_add_item(octo_tree,
+				hf_octo_proto_sequence,
+				tvb,
+				packet_offset(sequence),
+				packet_elem_size(sequence),
+				ENC_LITTLE_ENDIAN);
+		proto_tree_add_item(octo_tree,
+				hf_octo_proto_code,
+				tvb,
+				packet_offset(code),
+				packet_elem_size(code),
+				ENC_LITTLE_ENDIAN);
+		proto_tree_add_item(octo_tree,
+				hf_octo_proto_poolsize,
+				tvb,
+				packet_offset(poolsize),
+				packet_elem_size(poolsize),
+				ENC_LITTLE_ENDIAN);
+
+		//packet_code_t code = (packet_code_t)(tvb_get_guint8(tvb, packet_offset(code)));
+
+		guint16 len = tvb_get_letohs(tvb, packet_offset(len));
+		if(len && len <= packet_elem_size(data))
+		{
+			proto_tree_add_item(octo_tree,
+					hf_octo_proto_payload,
+					tvb,
+					packet_offset(data),
+					len,
+					ENC_LITTLE_ENDIAN);
+		}
+		proto_tree_add_item(octo_tree,
+				hf_octo_proto_data,
+				tvb,
+				packet_offset(data),
+				packet_elem_size(data),
+				ENC_LITTLE_ENDIAN);
+		proto_tree_add_item(octo_tree,
+				hf_octo_proto_len,
+				tvb,
+				packet_offset(len),
+				packet_elem_size(len),
+				ENC_LITTLE_ENDIAN);
+	}
+}
+
+
+void proto_register_octo(void)
+{
+	static hf_register_info hf[] = {
+		{ &hf_octo_proto_version,
+			{ "version", "octo.rev",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				"Protocol Revision", HFILL }
+		},
+		{ &hf_octo_proto_sequence,
+			{ "sequence number", "octo.seq",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_octo_proto_code,
+			{ "code", "octo.code",
+				FT_UINT8, BASE_DEC,
+				VALS(packetcodes), 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_octo_proto_poolsize,
+			{ "poolsize", "octo.poolsize",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_octo_proto_payload,
+			{ "payload", "octo.payload",
+				FT_STRING, BASE_NONE,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_octo_proto_data,
+			{ "data", "octo.data",
+				FT_BYTES, BASE_NONE,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_octo_proto_len,
+			{ "length", "octo.len",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		}
+	};
+	//protocol subtree array
+	static gint *ett[] = {
+		&ett_octo
+	};
+	proto_octo = proto_register_protocol(
+			"Octoclock",
+			"Octoclock",
+			"octo"
+			);
+
+	proto_register_field_array(proto_octo, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+	register_dissector("octo", dissect_octo, proto_octo);
+}
+
+void proto_reg_handoff_octo(void)
+{
+	static dissector_handle_t octo_handle;
+	octo_handle = create_dissector_handle(dissect_octo, proto_octo);
+	dissector_add_uint("udp.port", OCTOCLOCK_PORT, octo_handle);
+	dissector_add_uint("udp.port", OCTOCLOCK_UDP_GPSDO_PORT, octo_handle);
+}
diff --git a/tools/octoclock-dissector/plugin.rc.in b/tools/octoclock-dissector/plugin.rc.in
new file mode 100644
index 0000000..7fde51b
--- /dev/null
+++ b/tools/octoclock-dissector/plugin.rc.in
@@ -0,0 +1,34 @@
+#include "winver.h"
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION @RC_MODULE_VERSION@
+ PRODUCTVERSION @RC_VERSION@
+ FILEFLAGSMASK 0x0L
+#ifdef _DEBUG
+ FILEFLAGS VS_FF_DEBUG
+#else
+ FILEFLAGS 0
+#endif
+ FILEOS VOS_NT_WINDOWS32
+ FILETYPE VFT_DLL
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "CompanyName", "Ettus Research\0"
+            VALUE "FileDescription", "@PACKAGE@ dissector\0"
+            VALUE "FileVersion", "@MODULE_VERSION@\0"
+            VALUE "InternalName", "@PACKAGE@ @MODULE_VERSION@\0"
+            VALUE "LegalCopyright", "Copyright © 2016 Ettus Research\0"
+            VALUE "OriginalFilename", "@PLUGIN_NAME@.dll\0"
+            VALUE "ProductName", "Wireshark\0"
+            VALUE "ProductVersion", "@VERSION@\0"
+            VALUE "Comments", "Build with @MSVC_VARIANT@\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
-- 
2.1.4

