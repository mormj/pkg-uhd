From aa1665958756ab02342bb13c41f14aec6f0ef3f4 Mon Sep 17 00:00:00 2001
From: Nicholas Corgan <nick.corgan@ettus.com>
Date: Fri, 17 Jun 2016 09:09:25 -0700
Subject: [PATCH 21/42] octoclock: bugfixes, bumped firmware compat number to 4

* host: consistency in setting packet sequence numbers
* firmware: populate packet length field when setting GPSDO cache
* both: logic for dealing with mismatching compatibility numbers

Reviewed-By: Michael West <michael.west@ettus.com>
Reviewed-By: Martin Braun <martin.braun@ettus.com>
---
 firmware/octoclock/lib/udp_handlers.c              | 208 ++++++++++-----------
 host/lib/usrp_clock/octoclock/common.h             |   5 +-
 host/lib/usrp_clock/octoclock/octoclock_eeprom.cpp |   8 +-
 .../octoclock/octoclock_image_loader.cpp           |  42 +++--
 host/lib/usrp_clock/octoclock/octoclock_impl.cpp   |  25 ++-
 host/lib/usrp_clock/octoclock/octoclock_uart.cpp   |  11 +-
 host/lib/usrp_clock/octoclock/octoclock_uart.hpp   |   3 +-
 7 files changed, 164 insertions(+), 138 deletions(-)

diff --git a/firmware/octoclock/lib/udp_handlers.c b/firmware/octoclock/lib/udp_handlers.c
index 49b9b80..293d5f7 100644
--- a/firmware/octoclock/lib/udp_handlers.c
+++ b/firmware/octoclock/lib/udp_handlers.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Ettus Research LLC
+ * Copyright 2014,2016 Ettus Research LLC
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -36,89 +36,86 @@ void handle_udp_ctrl_packet(
     pkt_out.proto_ver = OCTOCLOCK_FW_COMPAT_NUM;
     pkt_out.sequence = pkt_in->sequence;
 
-    // If the firmware is incompatible, only respond to queries
-    if(pkt_in->code == OCTOCLOCK_QUERY_CMD){
-        pkt_out.code = OCTOCLOCK_QUERY_ACK;
-        pkt_out.len = 0;
-        send_udp_pkt(OCTOCLOCK_UDP_CTRL_PORT, src, (void*)&pkt_out, sizeof(octoclock_packet_t));
-    }
-    else if(pkt_in->proto_ver == OCTOCLOCK_FW_COMPAT_NUM){
-        switch(pkt_in->code){
-            case SEND_EEPROM_CMD:
-                pkt_out.code = SEND_EEPROM_ACK;
-                pkt_out.len = sizeof(octoclock_fw_eeprom_t);
-
-                octoclock_fw_eeprom_t *eeprom_info = (octoclock_fw_eeprom_t*)pkt_out.data;
-
-                // Read values from EEPROM into packet
-                eeprom_busy_wait();
-                eeprom_read_block(eeprom_info, 0, sizeof(octoclock_fw_eeprom_t));
-
-                // If EEPROM network fields are not fully populated, copy defaults
-                if(using_network_defaults){
-                    _MAC_ADDR(eeprom_info->mac_addr, 0x00,0x80,0x2F,0x11,0x22,0x33);
-                    eeprom_info->ip_addr = _IP(192,168,10,3);
-                    eeprom_info->dr_addr = _IP(192,168,10,1);
-                    eeprom_info->netmask = _IP(255,255,255,0);
-                }
-
-                // Check if strings or revision is empty
-                if(eeprom_info->revision == 0xFF) eeprom_info->revision = 0;
-                break;
-
-            case BURN_EEPROM_CMD:{
-                // Confirm length of data
-                if(pkt_in->len != sizeof(octoclock_fw_eeprom_t)){
-                    pkt_out.code = BURN_EEPROM_FAILURE_ACK;
-                    break;
-                }
-
-                /*
-                 * It is up to the host to make sure that the values that should be
-                 * preserved are present in the octoclock_fw_eeprom_t struct.
-                 */
-                const octoclock_fw_eeprom_t *eeprom_pkt = (octoclock_fw_eeprom_t*)pkt_in->data;
-                pkt_out.len = 0;
-
-                // Write EEPROM data from packet
-                eeprom_busy_wait();
-                eeprom_write_block(eeprom_pkt, 0, sizeof(octoclock_fw_eeprom_t));
-
-                // Read back and compare to packet to confirm successful write
-                uint8_t eeprom_contents[sizeof(octoclock_fw_eeprom_t)];
-                eeprom_busy_wait();
-                eeprom_read_block(eeprom_contents, 0, sizeof(octoclock_fw_eeprom_t));
-                uint8_t n = memcmp(eeprom_contents, eeprom_pkt, sizeof(octoclock_fw_eeprom_t));
-                pkt_out.code = n ? BURN_EEPROM_FAILURE_ACK
-                                 : BURN_EEPROM_SUCCESS_ACK;
-                break;
+    switch(pkt_in->code){
+        case OCTOCLOCK_QUERY_CMD:
+            pkt_out.code = OCTOCLOCK_QUERY_ACK;
+            pkt_out.len = 0;
+            break;
+
+        case RESET_CMD:
+            pkt_out.code = RESET_ACK;
+            send_udp_pkt(OCTOCLOCK_UDP_CTRL_PORT, src, (void*)&pkt_out, sizeof(octoclock_packet_t));
+            wdt_enable(WDTO_30MS);
+            while(1);
+            break;
+
+        case SEND_EEPROM_CMD:
+            pkt_out.code = SEND_EEPROM_ACK;
+            pkt_out.len = sizeof(octoclock_fw_eeprom_t);
+
+            octoclock_fw_eeprom_t *eeprom_info = (octoclock_fw_eeprom_t*)pkt_out.data;
+
+            // Read values from EEPROM into packet
+            eeprom_busy_wait();
+            eeprom_read_block(eeprom_info, 0, sizeof(octoclock_fw_eeprom_t));
+
+            // If EEPROM network fields are not fully populated, copy defaults
+            if(using_network_defaults){
+                _MAC_ADDR(eeprom_info->mac_addr, 0x00,0x80,0x2F,0x11,0x22,0x33);
+                eeprom_info->ip_addr = _IP(192,168,10,3);
+                eeprom_info->dr_addr = _IP(192,168,10,1);
+                eeprom_info->netmask = _IP(255,255,255,0);
             }
 
-            case SEND_STATE_CMD:
-                pkt_out.code = SEND_STATE_ACK;
-                pkt_out.len = sizeof(octoclock_state_t);
+            // Check if strings or revision is empty
+            if(eeprom_info->revision == 0xFF) eeprom_info->revision = 0;
+            break;
 
-                // Populate octoclock_state_t fields
-                octoclock_state_t *state = (octoclock_state_t*)pkt_out.data;
-                state->external_detected = g_ext_ref_present ? 1 : 0;
-                state->gps_detected      = g_gps_present     ? 1 : 0;
-                state->which_ref         = (uint8_t)g_ref;
-                state->switch_pos        = (uint8_t)g_switch_pos;
+        case BURN_EEPROM_CMD:{
+            // Confirm length of data
+            if(pkt_in->len != sizeof(octoclock_fw_eeprom_t)){
+                pkt_out.code = BURN_EEPROM_FAILURE_ACK;
                 break;
+            }
 
-            case RESET_CMD:
-                pkt_out.code = RESET_ACK;
-                send_udp_pkt(OCTOCLOCK_UDP_CTRL_PORT, src, (void*)&pkt_out, sizeof(octoclock_packet_t));
-                wdt_enable(WDTO_30MS);
-                while(1);
-                return;
-
-            default:
-                return;
+            /*
+             * It is up to the host to make sure that the values that should be
+             * preserved are present in the octoclock_fw_eeprom_t struct.
+             */
+            const octoclock_fw_eeprom_t *eeprom_pkt = (octoclock_fw_eeprom_t*)pkt_in->data;
+            pkt_out.len = 0;
+
+            // Write EEPROM data from packet
+            eeprom_busy_wait();
+            eeprom_write_block(eeprom_pkt, 0, sizeof(octoclock_fw_eeprom_t));
+
+            // Read back and compare to packet to confirm successful write
+            uint8_t eeprom_contents[sizeof(octoclock_fw_eeprom_t)];
+            eeprom_busy_wait();
+            eeprom_read_block(eeprom_contents, 0, sizeof(octoclock_fw_eeprom_t));
+            uint8_t n = memcmp(eeprom_contents, eeprom_pkt, sizeof(octoclock_fw_eeprom_t));
+            pkt_out.code = n ? BURN_EEPROM_FAILURE_ACK
+                             : BURN_EEPROM_SUCCESS_ACK;
+            break;
         }
 
-        send_udp_pkt(OCTOCLOCK_UDP_CTRL_PORT, src, (void*)&pkt_out, sizeof(octoclock_packet_t));
+        case SEND_STATE_CMD:
+            pkt_out.code = SEND_STATE_ACK;
+            pkt_out.len = sizeof(octoclock_state_t);
+
+            // Populate octoclock_state_t fields
+            octoclock_state_t *state = (octoclock_state_t*)pkt_out.data;
+            state->external_detected = g_ext_ref_present ? 1 : 0;
+            state->gps_detected      = g_gps_present     ? 1 : 0;
+            state->which_ref         = (uint8_t)g_ref;
+            state->switch_pos        = (uint8_t)g_switch_pos;
+            break;
+
+        default:
+            return;
     }
+
+    send_udp_pkt(OCTOCLOCK_UDP_CTRL_PORT, src, (void*)&pkt_out, sizeof(octoclock_packet_t));
 }
 
 void handle_udp_gpsdo_packet(
@@ -130,35 +127,34 @@ void handle_udp_gpsdo_packet(
     pkt_out.proto_ver = OCTOCLOCK_FW_COMPAT_NUM;
     pkt_out.sequence = pkt_in->sequence;
 
-    if(pkt_in->proto_ver == OCTOCLOCK_FW_COMPAT_NUM){
-        switch(pkt_in->code){
-            case HOST_SEND_TO_GPSDO_CMD:
-                send_gpsdo_cmd((char*)pkt_in->data, pkt_in->len);
-                pkt_out.code = HOST_SEND_TO_GPSDO_ACK;
-                pkt_out.len = 0;
-                break;
-
-            case SEND_POOLSIZE_CMD:
-                pkt_out.code = SEND_POOLSIZE_ACK;
-                pkt_out.len = 0;
-                pkt_out.poolsize = POOLSIZE;
-                break;
-
-            case SEND_CACHE_STATE_CMD:
-                pkt_out.code = SEND_CACHE_STATE_ACK;
-                pkt_out.state = gpsdo_state;
-                break;
-
-            case SEND_GPSDO_CACHE_CMD:
-                pkt_out.code = SEND_GPSDO_CACHE_ACK;
-                pkt_out.state = gpsdo_state;
-                memcpy(pkt_out.data, gpsdo_buf, POOLSIZE);
-                break;
-
-            default:
-                return;
-        }
-
-        send_udp_pkt(OCTOCLOCK_UDP_GPSDO_PORT, src, (void*)&pkt_out, sizeof(octoclock_packet_t));
+    switch(pkt_in->code){
+        case HOST_SEND_TO_GPSDO_CMD:
+            send_gpsdo_cmd((char*)pkt_in->data, pkt_in->len);
+            pkt_out.code = HOST_SEND_TO_GPSDO_ACK;
+            pkt_out.len = 0;
+            break;
+
+        case SEND_POOLSIZE_CMD:
+            pkt_out.code = SEND_POOLSIZE_ACK;
+            pkt_out.len = 0;
+            pkt_out.poolsize = POOLSIZE;
+            break;
+
+        case SEND_CACHE_STATE_CMD:
+            pkt_out.code = SEND_CACHE_STATE_ACK;
+            pkt_out.state = gpsdo_state;
+            break;
+
+        case SEND_GPSDO_CACHE_CMD:
+            pkt_out.code = SEND_GPSDO_CACHE_ACK;
+            pkt_out.state = gpsdo_state;
+            pkt_out.len = POOLSIZE;
+            memcpy(pkt_out.data, gpsdo_buf, POOLSIZE);
+            break;
+
+        default:
+            return;
     }
+
+    send_udp_pkt(OCTOCLOCK_UDP_GPSDO_PORT, src, (void*)&pkt_out, sizeof(octoclock_packet_t));
 }
diff --git a/host/lib/usrp_clock/octoclock/common.h b/host/lib/usrp_clock/octoclock/common.h
index 89fec9c..191b93d 100644
--- a/host/lib/usrp_clock/octoclock/common.h
+++ b/host/lib/usrp_clock/octoclock/common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2015 Ettus Research LLC
+ * Copyright 2014-2016 Ettus Research LLC
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -46,7 +46,8 @@ extern "C" {
 
 // These values are placed in the octoclock_packet_t.proto_ver field
 #define OCTOCLOCK_BOOTLOADER_PROTO_VER 1234
-#define OCTOCLOCK_FW_COMPAT_NUM           3
+#define OCTOCLOCK_FW_MIN_COMPAT_NUM       2
+#define OCTOCLOCK_FW_COMPAT_NUM           4
 
 // UDP ports assigned for different tasks
 #define OCTOCLOCK_UDP_CTRL_PORT   50000
diff --git a/host/lib/usrp_clock/octoclock/octoclock_eeprom.cpp b/host/lib/usrp_clock/octoclock/octoclock_eeprom.cpp
index 49d1a04..8ac3801 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_eeprom.cpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_eeprom.cpp
@@ -1,5 +1,5 @@
 //
-// Copyright 2014-2015 Ettus Research LLC
+// Copyright 2014-2016 Ettus Research LLC
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -46,7 +46,8 @@ void octoclock_eeprom_t::_load(){
     const octoclock_fw_eeprom_t *eeprom_in = reinterpret_cast<const octoclock_fw_eeprom_t*>(pkt_in->data);
 
     octoclock_packet_t pkt_out;
-    pkt_out.sequence = uhd::htonx<boost::uint32_t>(std::rand());
+    // To avoid replicating sequence numbers between sessions
+    pkt_out.sequence = boost::uint32_t(std::rand());
     size_t len = 0;
 
     UHD_OCTOCLOCK_SEND_AND_RECV(xport, SEND_EEPROM_CMD, pkt_out, len, octoclock_data);
@@ -94,7 +95,8 @@ void octoclock_eeprom_t::_store() const {
     const octoclock_packet_t *pkt_in = reinterpret_cast<const octoclock_packet_t *>(octoclock_data);
 
     octoclock_packet_t pkt_out;
-    pkt_out.sequence = uhd::htonx<boost::uint32_t>(std::rand());
+    // To avoid replicating sequence numbers between sessions
+    pkt_out.sequence = boost::uint32_t(std::rand());
     pkt_out.len = sizeof(octoclock_fw_eeprom_t);
     size_t len = 0;
 
diff --git a/host/lib/usrp_clock/octoclock/octoclock_image_loader.cpp b/host/lib/usrp_clock/octoclock/octoclock_image_loader.cpp
index fdb2540..e12256c 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_image_loader.cpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_image_loader.cpp
@@ -1,5 +1,5 @@
 //
-// Copyright 2015 Ettus Research LLC
+// Copyright 2015-2016 Ettus Research LLC
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -59,9 +59,11 @@ typedef struct {
     std::string                 image_filepath;
     boost::uint16_t             crc;
     boost::uint16_t             num_blocks;
+    boost::uint32_t             sequence;
     udp_simple::sptr            ctrl_xport;
     udp_simple::sptr            fw_xport;
     boost::uint8_t              data_in[udp_simple::mtu];
+    boost::uint32_t             starting_firmware_version;
     std::vector<boost::uint8_t> image;
 } octoclock_session_t;
 
@@ -169,6 +171,19 @@ static void octoclock_setup_session(octoclock_session_t &session,
                                                     BOOST_STRINGIZE(OCTOCLOCK_UDP_CTRL_PORT));
     session.fw_xport   = udp_simple::make_connected(session.dev_addr["addr"],
                                                     BOOST_STRINGIZE(OCTOCLOCK_UDP_FW_PORT));
+    // To avoid replicating sequence numbers between sessions
+    session.sequence   = boost::uint32_t(std::rand());
+
+    // Query OctoClock again to get compat number
+    octoclock_packet_t pkt_out;
+    const octoclock_packet_t* pkt_in = reinterpret_cast<const octoclock_packet_t*>(session.data_in);
+    size_t len = 0;
+    UHD_OCTOCLOCK_SEND_AND_RECV(session.ctrl_xport, OCTOCLOCK_QUERY_CMD, pkt_out, len, session.data_in);
+    if(UHD_OCTOCLOCK_PACKET_MATCHES(OCTOCLOCK_QUERY_ACK, pkt_out, pkt_in, len)){
+        session.starting_firmware_version = uhd::htonx<boost::uint32_t>(pkt_in->proto_ver);
+    } else {
+        throw uhd::runtime_error("Failed to communicate with OctoClock.");
+    }
 }
 
 static void octoclock_reset_into_bootloader(octoclock_session_t &session){
@@ -177,15 +192,18 @@ static void octoclock_reset_into_bootloader(octoclock_session_t &session){
     if(session.dev_addr["type"] == "octoclock-bootloader")
         return;
 
+    // Force compat num to device's current, works around old firmware bug
     octoclock_packet_t pkt_out;
-    pkt_out.sequence = uhd::htonx<boost::uint32_t>(std::rand());
-    const octoclock_packet_t* pkt_in = reinterpret_cast<const octoclock_packet_t*>(session.data_in);
-    size_t len;
+    pkt_out.sequence = uhd::htonx<boost::uint32_t>(++session.sequence);
+    pkt_out.proto_ver = uhd::htonx<boost::uint32_t>(session.starting_firmware_version);
+    pkt_out.code = RESET_CMD;
 
     std::cout << " -- Resetting into bootloader..." << std::flush;
-    UHD_OCTOCLOCK_SEND_AND_RECV(session.ctrl_xport, RESET_CMD, pkt_out, len, session.data_in);
-    if(UHD_OCTOCLOCK_PACKET_MATCHES(RESET_ACK, pkt_out, pkt_in, len)){
+    session.ctrl_xport->send(boost::asio::buffer(&pkt_out, sizeof(octoclock_packet_t))); \
+    size_t len = session.ctrl_xport->recv(boost::asio::buffer(session.data_in), 2);\
+    const octoclock_packet_t* pkt_in = reinterpret_cast<const octoclock_packet_t*>(session.data_in);
 
+    if(UHD_OCTOCLOCK_PACKET_MATCHES(RESET_ACK, pkt_out, pkt_in, len)){
         // Make sure this device is now in its bootloader
         boost::this_thread::sleep(boost::posix_time::milliseconds(500));
         uhd::device_addrs_t octoclocks = uhd::device::find(
@@ -217,7 +235,7 @@ static void octoclock_burn(octoclock_session_t &session){
     octoclock_reset_into_bootloader(session);
 
     octoclock_packet_t pkt_out;
-    pkt_out.sequence = htonx<boost::uint32_t>(std::rand());
+    pkt_out.sequence = uhd::htonx<boost::uint32_t>(++session.sequence);
     const octoclock_packet_t* pkt_in = reinterpret_cast<const octoclock_packet_t*>(session.data_in);
 
     // Tell OctoClock to prepare for burn
@@ -237,7 +255,7 @@ static void octoclock_burn(octoclock_session_t &session){
 
     // Start burning
     for(size_t i = 0; i < session.num_blocks; i++){
-        pkt_out.sequence++;
+        pkt_out.sequence = uhd::htonx<boost::uint32_t>(++session.sequence);
         pkt_out.addr = i * OCTOCLOCK_BLOCK_SIZE;
 
         std::cout << str(boost::format("\r -- Loading firmware: %d%% (%d/%d blocks)")
@@ -260,16 +278,16 @@ static void octoclock_burn(octoclock_session_t &session){
 }
 
 static void octoclock_verify(octoclock_session_t &session){
-    
+
     octoclock_packet_t pkt_out;
-    pkt_out.sequence = htonx<boost::uint32_t>(std::rand());
+    pkt_out.sequence = uhd::htonx<boost::uint32_t>(++session.sequence);
     const octoclock_packet_t* pkt_in = reinterpret_cast<const octoclock_packet_t*>(session.data_in);
     size_t len = 0;
 
     boost::uint8_t image_part[OCTOCLOCK_BLOCK_SIZE];
     boost::uint16_t cmp_len = 0;
     for(size_t i = 0; i < session.num_blocks; i++){
-        pkt_out.sequence++;
+        pkt_out.sequence = uhd::htonx<boost::uint32_t>(++session.sequence);
         pkt_out.addr = i * OCTOCLOCK_BLOCK_SIZE;
 
         std::cout << str(boost::format("\r -- Verifying firmware load: %d%% (%d/%d blocks)")
@@ -302,7 +320,7 @@ static void octoclock_verify(octoclock_session_t &session){
 static void octoclock_finalize(octoclock_session_t &session){
 
     octoclock_packet_t pkt_out;
-    pkt_out.sequence = htonx<boost::uint32_t>(std::rand());
+    pkt_out.sequence = uhd::htonx<boost::uint32_t>(++session.sequence);
     const octoclock_packet_t* pkt_in = reinterpret_cast<const octoclock_packet_t*>(session.data_in);
     size_t len = 0;
 
diff --git a/host/lib/usrp_clock/octoclock/octoclock_impl.cpp b/host/lib/usrp_clock/octoclock/octoclock_impl.cpp
index 5ea242e..4f70a82 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_impl.cpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_impl.cpp
@@ -110,7 +110,8 @@ device_addrs_t octoclock_find(const device_addr_t &hint){
     //Send a query packet
     octoclock_packet_t pkt_out;
     pkt_out.proto_ver = OCTOCLOCK_FW_COMPAT_NUM;
-    pkt_out.sequence = uhd::htonx<boost::uint32_t>(std::rand());
+    // To avoid replicating sequence numbers between sessions
+    pkt_out.sequence = boost::uint32_t(std::rand());
     pkt_out.len = 0;
     pkt_out.code = OCTOCLOCK_QUERY_CMD;
     try{
@@ -144,12 +145,17 @@ device_addrs_t octoclock_find(const device_addr_t &hint){
                     new_addr["type"] = "octoclock-bootloader";
                     octoclock_addrs.push_back(new_addr);
                 }
-                else{
+                else {
                     new_addr["type"] = "octoclock";
 
-                    octoclock_eeprom_t oc_eeprom(ctrl_xport);
-                    new_addr["name"] = oc_eeprom["name"];
-                    new_addr["serial"] = oc_eeprom["serial"];
+                    if(pkt_in->proto_ver >= OCTOCLOCK_FW_MIN_COMPAT_NUM and pkt_in->proto_ver <= OCTOCLOCK_FW_COMPAT_NUM) {
+                        octoclock_eeprom_t oc_eeprom(ctrl_xport);
+                        new_addr["name"] = oc_eeprom["name"];
+                        new_addr["serial"] = oc_eeprom["serial"];
+                    } else {
+                        new_addr["name"] = "";
+                        new_addr["serial"] = "";
+                    }
 
                     //Filter based on optional keys (if any)
                     if(
@@ -184,7 +190,8 @@ octoclock_impl::octoclock_impl(const device_addr_t &_device_addr){
     UHD_MSG(status) << "Opening an OctoClock device..." << std::endl;
     _type = device::CLOCK;
     device_addrs_t device_args = separate_device_addr(_device_addr);
-    _sequence = std::rand();
+    // To avoid replicating sequence numbers between sessions
+    _sequence = boost::uint32_t(std::rand());
 
     ////////////////////////////////////////////////////////////////////
     // Initialize the property tree
@@ -220,7 +227,7 @@ octoclock_impl::octoclock_impl(const device_addr_t &_device_addr){
         // Check the firmware compatibility number
         ////////////////////////////////////////////////////////////////////
         boost::uint32_t fw_version = _get_fw_version(oc);
-        if(fw_version != OCTOCLOCK_FW_COMPAT_NUM){
+        if(fw_version < OCTOCLOCK_FW_MIN_COMPAT_NUM or fw_version > OCTOCLOCK_FW_COMPAT_NUM){
             throw uhd::runtime_error(str(boost::format(
                     "\n\nPlease update your OctoClock's firmware.\n"
                     "Expected firmware compatibility number %d, but got %d:\n"
@@ -325,7 +332,7 @@ void octoclock_impl::_set_eeprom(const std::string &oc, const octoclock_eeprom_t
 
 boost::uint32_t octoclock_impl::_get_fw_version(const std::string &oc){
     octoclock_packet_t pkt_out;
-    pkt_out.sequence = _sequence++;
+    pkt_out.sequence = uhd::htonx<boost::uint32_t>(++_sequence);
     pkt_out.len = 0;
     size_t len;
 
@@ -341,7 +348,7 @@ boost::uint32_t octoclock_impl::_get_fw_version(const std::string &oc){
 
 void octoclock_impl::_get_state(const std::string &oc){
     octoclock_packet_t pkt_out;
-    pkt_out.sequence = _sequence++;
+    pkt_out.sequence = uhd::htonx<boost::uint32_t>(++_sequence);
     pkt_out.len = 0;
     size_t len = 0;
 
diff --git a/host/lib/usrp_clock/octoclock/octoclock_uart.cpp b/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
index 4d02aad..e0a9f08 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_uart.cpp
@@ -1,5 +1,5 @@
 //
-// Copyright 2014-2015 Ettus Research LLC
+// Copyright 2014-2016 Ettus Research LLC
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -47,11 +47,13 @@ namespace uhd{
         _state.pos = 0;
         _device_state.num_wraps = 0;
         _device_state.pos = 0;
+        // To avoid replicating sequence numbers between sessions
+        _sequence = boost::uint32_t(std::rand());
         size_t len = 0;
 
         //Get pool size from device
         octoclock_packet_t pkt_out;
-        pkt_out.sequence = uhd::htonx<boost::uint16_t>(std::rand());
+        pkt_out.sequence = uhd::htonx<boost::uint32_t>(_sequence);
         pkt_out.len = 0;
 
         boost::uint8_t octoclock_data[udp_simple::mtu];
@@ -70,7 +72,7 @@ namespace uhd{
         size_t len = 0;
 
         octoclock_packet_t pkt_out;
-        pkt_out.sequence = uhd::htonx<boost::uint32_t>(std::rand());
+        pkt_out.sequence = uhd::htonx<boost::uint32_t>(++_sequence);
         pkt_out.len = to_send.size();
         memcpy(pkt_out.data, to_send.c_str(), to_send.size());
 
@@ -111,14 +113,13 @@ namespace uhd{
     void octoclock_uart_iface::_update_cache(){
         octoclock_packet_t pkt_out;
         pkt_out.len = 0;
-        pkt_out.sequence = 0;
         size_t len = 0;
 
         boost::uint8_t octoclock_data[udp_simple::mtu];
         const octoclock_packet_t *pkt_in = reinterpret_cast<octoclock_packet_t*>(octoclock_data);
 
         if(STATES_EQUAL or LOCAL_STATE_AHEAD){
-            pkt_out.sequence++;
+            pkt_out.sequence = uhd::htonx<boost::uint32_t>(++_sequence);
             UHD_OCTOCLOCK_SEND_AND_RECV(_udp, SEND_GPSDO_CACHE_CMD, pkt_out, len, octoclock_data);
             if(UHD_OCTOCLOCK_PACKET_MATCHES(SEND_GPSDO_CACHE_ACK, pkt_out, pkt_in, len)){
                 memcpy(&_cache[0], pkt_in->data, _poolsize);
diff --git a/host/lib/usrp_clock/octoclock/octoclock_uart.hpp b/host/lib/usrp_clock/octoclock/octoclock_uart.hpp
index 05d1bb1..d7a7728 100644
--- a/host/lib/usrp_clock/octoclock/octoclock_uart.hpp
+++ b/host/lib/usrp_clock/octoclock/octoclock_uart.hpp
@@ -1,5 +1,5 @@
 //
-// Copyright 2014 Ettus Research LLC
+// Copyright 2014,2016 Ettus Research LLC
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -45,6 +45,7 @@ private:
     gpsdo_cache_state_t _device_state;
     std::vector<boost::uint8_t> _cache;
     std::string _rxbuff;
+    boost::uint32_t _sequence;
 
     void _update_cache();
     char _getchar();
-- 
2.1.4

