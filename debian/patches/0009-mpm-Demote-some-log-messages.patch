From 91d05047ceeb57dcb2d7ddb1c46d049b594895c9 Mon Sep 17 00:00:00 2001
From: Martin Braun <martin.braun@ettus.com>
Date: Tue, 6 Mar 2018 15:16:22 -0800
Subject: [PATCH 09/40] mpm: Demote some log messages

The log output at level 'INFO' was pretty cluttered. This cleans up the
log messages at the higher levels. In some cases, log message typos or
capitalizations were also fixed.
---
 mpm/python/usrp_mpm/chips/lmk04828.py            |  4 +--
 mpm/python/usrp_mpm/cores/tdc_sync.py            |  4 +--
 mpm/python/usrp_mpm/dboard_manager/base.py       |  2 +-
 mpm/python/usrp_mpm/dboard_manager/eiscat.py     | 18 +++++-----
 mpm/python/usrp_mpm/dboard_manager/lmk_eiscat.py |  4 +--
 mpm/python/usrp_mpm/dboard_manager/lmk_mg.py     |  6 ++--
 mpm/python/usrp_mpm/dboard_manager/magnesium.py  | 13 ++++---
 mpm/python/usrp_mpm/discovery.py                 | 10 +++---
 mpm/python/usrp_mpm/periph_manager/base.py       | 14 ++++----
 mpm/python/usrp_mpm/periph_manager/n3xx.py       | 43 ++++++++++++------------
 mpm/python/usrp_mpm/xports/xportmgr_udp.py       |  2 +-
 11 files changed, 59 insertions(+), 61 deletions(-)

diff --git a/mpm/python/usrp_mpm/chips/lmk04828.py b/mpm/python/usrp_mpm/chips/lmk04828.py
index c0496a6af..5075f1bbf 100644
--- a/mpm/python/usrp_mpm/chips/lmk04828.py
+++ b/mpm/python/usrp_mpm/chips/lmk04828.py
@@ -64,8 +64,8 @@ class LMK04828(object):
             """
             pll_lock_status = self.regs_iface.peek8(addr)
             if (pll_lock_status & 0x7) != 0x02:
-                self.log.warning("{} reporting unlocked... Status: 0x{:x}"
-                                 .format(pll_id, pll_lock_status))
+                self.log.debug("{} reporting unlocked... Status: 0x{:x}"
+                               .format(pll_id, pll_lock_status))
                 return False
             return True
         lock_status = \
diff --git a/mpm/python/usrp_mpm/cores/tdc_sync.py b/mpm/python/usrp_mpm/cores/tdc_sync.py
index 1ded38fef..cbed98244 100644
--- a/mpm/python/usrp_mpm/cores/tdc_sync.py
+++ b/mpm/python/usrp_mpm/cores/tdc_sync.py
@@ -187,7 +187,7 @@ class ClockSynchronizer(object):
         # the offset at this point (see __init__), so self.peek32(0x0000) should read the
         # first offset if you kept your reg offset at 0 in your netlist
 
-        self.log.info("Running clock synchronization...")
+        self.log.debug("Running clock synchronization...")
         self.log.trace("Using reference clock frequency: {} MHz".format(self.ref_clk_freq/1e6))
         self.log.trace("Using master clock frequency: {} MHz".format(self.radio_clk_freq/1e6))
 
@@ -444,7 +444,7 @@ class ClockSynchronizer(object):
         inc = math.floor((high_bound - low_bound)/(middle_samples + 1.0))
 
         for x in range(middle_samples + 2):
-            self.log.info("Test Progress: {:.2f}%".format(x*100/(middle_samples+2)))
+            self.log.debug("Test Progress: {:.2f}%".format(x*100/(middle_samples+2)))
             self.write_dac_word(x*inc + low_bound, 0.1)
             distance_to_target = self.run_sync(measurement_only=True)
             meas_file.write("{}, {:.4f}\n".format(x*inc + low_bound, distance_to_target*1e12))
diff --git a/mpm/python/usrp_mpm/dboard_manager/base.py b/mpm/python/usrp_mpm/dboard_manager/base.py
index 68a3f3d5b..36f446360 100644
--- a/mpm/python/usrp_mpm/dboard_manager/base.py
+++ b/mpm/python/usrp_mpm/dboard_manager/base.py
@@ -39,7 +39,7 @@ class DboardManagerBase(object):
         self.log = get_logger('dboardManager')
         self.slot_idx = slot_idx
         if 'eeprom_md' not in kwargs:
-            self.log.warn("No EEPROM metadata given!")
+            self.log.debug("No EEPROM metadata given!")
         # In C++, we can only handle dicts if all the values are of the
         # same type. So we must convert them all to strings here:
         self.device_info = {
diff --git a/mpm/python/usrp_mpm/dboard_manager/eiscat.py b/mpm/python/usrp_mpm/dboard_manager/eiscat.py
index 2b1c247ba..3581784ea 100644
--- a/mpm/python/usrp_mpm/dboard_manager/eiscat.py
+++ b/mpm/python/usrp_mpm/dboard_manager/eiscat.py
@@ -71,7 +71,7 @@ class ADS54J56(object):
         else:
             self.sync_line = "AB"
         assert self.sync_line in ('AB', 'CD')
-        self.log.debug(
+        self.log.trace(
             "The next setup() sequence will use sync pin: {}".format(
                 self.sync_line
             )
@@ -513,25 +513,25 @@ class EISCAT(DboardManagerBase):
                 self.log.debug("Residual DAC offset error: {} ps.".format(
                     offset_error*1e12
                 ))
-            self.log.info("Clock Synchronization Complete!")
+            self.log.debug("Clock Synchronization Complete!")
         # Go, go, go!
         if args.get("force_init", False):
             self.log.info("Forcing re-initialization of dboard.")
         self.initialized = args.get("force_init", self.initialized)
         if self.initialized:
-            self.log.info(
+            self.log.debug(
                 "Dboard was previously initialized; skipping init. " \
                 "Specify force_init=1 to force initialization."
             )
             return True
-        self.log.info("init() called with args `{}'".format(
+        self.log.debug("init() called with args `{}'".format(
             ",".join(['{}={}'.format(x, args[x]) for x in args])
         ))
         self.radio_regs = _init_dboard_regs()
         self.jesd_cores = _init_jesd_cores(self.radio_regs, self.slot_idx)
-        self.log.info("Radio-register UIO object successfully generated!")
+        self.log.debug("Radio-register UIO object successfully generated!")
         self._spi_ifaces = _init_spi_devices() # Chips don't have power yet!
-        self.log.info("Loaded SPI interfaces!")
+        self.log.debug("Loaded SPI interfaces!")
         self._init_power(self.radio_regs) # Now, we can talk to chips via SPI
         self.dboard_clk_control = _init_clock_control(self.radio_regs)
         self.lmk = _init_lmk(
@@ -546,7 +546,7 @@ class EISCAT(DboardManagerBase):
             for spi_iface in ('adc0', 'adc1')
         ]
         self.dboard_clk_control.enable_mmcm()
-        self.log.info("Clocking Configured Successfully!")
+        self.log.debug("Clocking Configured Successfully!")
         # Synchronize DB Clocks
         self.clock_synchronizer = ClockSynchronizer(
             self.radio_regs,
@@ -618,7 +618,7 @@ class EISCAT(DboardManagerBase):
             return True
         for adc in self.adcs:
             adc.setup()
-        self.log.info("ADC Initialization Complete!")
+        self.log.debug("ADC Initialization Complete!")
         for jesd_core in self.jesd_cores:
             jesd_core.init_deframer()
         return True
@@ -649,7 +649,7 @@ class EISCAT(DboardManagerBase):
         if error:
             return False
 
-        self.log.info("JESD Core Initialized, link up! (woohoo!)")
+        self.log.debug("JESD Core Initialized, link up! (woohoo!)")
         self.initialized = True
         return self.initialized
 
diff --git a/mpm/python/usrp_mpm/dboard_manager/lmk_eiscat.py b/mpm/python/usrp_mpm/dboard_manager/lmk_eiscat.py
index 1fb756955..c2f35232d 100644
--- a/mpm/python/usrp_mpm/dboard_manager/lmk_eiscat.py
+++ b/mpm/python/usrp_mpm/dboard_manager/lmk_eiscat.py
@@ -30,7 +30,7 @@ class LMK04828EISCAT(LMK04828):
         """
         Basic init. Turns it on. Let's us read SPI.
         """
-        self.log.info("Reset LMK & Verify")
+        self.log.debug("Reset LMK & Verify")
         self.pokes8((
             (0x000, 0x90), # Assert reset
             (0x000, 0x10), # De-assert reset
@@ -183,7 +183,7 @@ class LMK04828EISCAT(LMK04828):
             (0x144, 0xFF), # Disable SYNC on all outputs including sysref
             (0x143, 0x52), # Pulser selected; SYNC enabled; 1 shot enabled
         ))
-        self.log.info("LMK init'd and locked!")
+        self.log.debug("LMK init'd and locked!")
 
     def lmk_shift(self, num_shifts=0):
         """
diff --git a/mpm/python/usrp_mpm/dboard_manager/lmk_mg.py b/mpm/python/usrp_mpm/dboard_manager/lmk_mg.py
index 22d3de983..3cb6ea7c9 100644
--- a/mpm/python/usrp_mpm/dboard_manager/lmk_mg.py
+++ b/mpm/python/usrp_mpm/dboard_manager/lmk_mg.py
@@ -61,7 +61,7 @@ class LMK04828Mg(LMK04828):
         """
         Basic init. Turns it on. Let's read SPI.
         """
-        self.log.info("Reset and Verify Chip ID")
+        self.log.debug("Reset and Verify Chip ID")
         self.pokes8((
             (0x000, 0x90), # Assert reset
             (0x000, 0x10), # De-assert reset
@@ -78,7 +78,7 @@ class LMK04828Mg(LMK04828):
         clkout_div_val = self.divide_to_reg(self.clkout_divider)
         clkout_cnt_val = self.divide_to_cnth_cntl_reg(self.clkout_divider)
 
-        self.log.info("Register Initialization Commencing...")
+        self.log.debug("Register Initialization Commencing...")
         self.pokes8((
             (0x100, clkout_div_val), # CLKout Config
             (0x101, clkout_cnt_val), # CLKout Config
@@ -225,7 +225,7 @@ class LMK04828Mg(LMK04828):
             (0x144, 0xFF), # Disable SYNC on all outputs including sysref
             (0x143, 0x52), # Pulser selected; SYNC enabled; 1 shot enabled
         ))
-        self.log.info("Clocks Initialized and PLLs Locked!")
+        self.log.debug("Clocks Initialized and PLLs Locked!")
 
     def lmk_shift(self, num_shifts=0):
         """
diff --git a/mpm/python/usrp_mpm/dboard_manager/magnesium.py b/mpm/python/usrp_mpm/dboard_manager/magnesium.py
index 470723e02..7d56dea67 100644
--- a/mpm/python/usrp_mpm/dboard_manager/magnesium.py
+++ b/mpm/python/usrp_mpm/dboard_manager/magnesium.py
@@ -371,10 +371,10 @@ class Magnesium(DboardManagerBase):
                 self.log.debug("Residual DAC offset error: {:.1f} ps.".format(
                     offset_error*1e12
                 ))
-            self.log.info("Sample Clock Synchronization Complete!")
+            self.log.debug("Sample Clock Synchronization Complete!")
         ## Go, go, go!
         # Sanity checks and input validation:
-        self.log.info("init() called with args `{}'".format(
+        self.log.debug("init() called with args `{}'".format(
             ",".join(['{}={}'.format(x, args[x]) for x in args])
         ))
         if not self._periphs_initialized:
@@ -422,7 +422,7 @@ class Magnesium(DboardManagerBase):
                 self.INIT_PHASE_DAC_WORD,
             )
             db_clk_control.enable_mmcm()
-            self.log.info("Sample Clocks and Phase DAC Configured Successfully!")
+            self.log.debug("Sample Clocks and Phase DAC Configured Successfully!")
             # Synchronize DB Clocks
             _sync_db_clock(_get_clock_synchronizer())
             # Clocks and PPS are now fully active!
@@ -464,7 +464,7 @@ class Magnesium(DboardManagerBase):
 
     def init_rf_cal(self, args):
         " Setup RF CAL "
-        self.log.info("Setting up RF CAL...")
+        self.log.debug("Setting up RF CAL...")
         try:
             self._init_cals_mask = \
                     self._parse_and_convert_cal_args(
@@ -507,8 +507,7 @@ class Magnesium(DboardManagerBase):
         Arguments:
             args {string:string} -- device arguments.
         """
-
-        self.log.info("Setting up LO source..")
+        self.log.debug("Setting up LO source..")
         rx_lo_source = args.get("rx_lo_source", "internal")
         tx_lo_source = args.get("tx_lo_source", "internal")
         self.mykonos.set_lo_source("RX", rx_lo_source)
@@ -587,7 +586,7 @@ class Magnesium(DboardManagerBase):
             error_flag = True
         if error_flag:
             raise RuntimeError('JESD204B Link Initialization Failed. See MPM logs for details.')
-        self.log.info("JESD204B Link Initialization & Training Complete")
+        self.log.debug("JESD204B Link Initialization & Training Complete")
 
     def check_mykonos_framer_status(self):
         " Return True if Mykonos Framer is in good state "
diff --git a/mpm/python/usrp_mpm/discovery.py b/mpm/python/usrp_mpm/discovery.py
index c1a894276..2efd25b80 100644
--- a/mpm/python/usrp_mpm/discovery.py
+++ b/mpm/python/usrp_mpm/discovery.py
@@ -75,25 +75,25 @@ def _discovery_process(state, discovery_addr):
     try:
         while True:
             data, sender = sock.recvfrom(MAX_MTU)
-            log.info("Got poked by: %s", sender[0])
+            log.debug("Got poked by: %s", sender[0])
             # TODO this is still part of the awful subnet identification
             if not sender[0].startswith(discovery_addr_prefix):
                 continue
             if data.strip(b"\0") == b"MPM-DISC":
-                log.info("Sending discovery response to %s port: %d",
+                log.debug("Sending discovery response to %s port: %d",
                          sender[0], sender[1])
                 resp_str = create_response_string(state)
                 send_data = resp_str
-                log.info(send_data)
+                log.trace("Return data: %s", send_data)
                 send_sock.sendto(send_data, sender)
             elif data.strip(b"\0").startswith(b"MPM-ECHO"):
-                log.info("Received echo request from {sender}"
+                log.debug("Received echo request from {sender}"
                          .format(sender=sender[0]))
                 send_data = data
                 try:
                     send_sock.sendto(send_data, sender)
                 except OSError as ex:
-                    log.debug("ECHO send error: %s", str(ex))
+                    log.warning("ECHO send error: %s", str(ex))
     except Exception as err:
         log.error("Unexpected error: `%s' Type: `%s'", str(err), type(err))
         sock.close()
diff --git a/mpm/python/usrp_mpm/periph_manager/base.py b/mpm/python/usrp_mpm/periph_manager/base.py
index 83096c994..6e72950fb 100644
--- a/mpm/python/usrp_mpm/periph_manager/base.py
+++ b/mpm/python/usrp_mpm/periph_manager/base.py
@@ -257,7 +257,7 @@ class PeriphManagerBase(object):
             eeprom_md,
             device_args,
         )
-        self.log.trace("Motherboard requires device tree overlays: {}".format(
+        self.log.trace("Motherboard requests device tree overlays: {}".format(
             requested_overlays
         ))
         for overlay in requested_overlays:
@@ -273,7 +273,7 @@ class PeriphManagerBase(object):
         # Go, go, go!
         override_dboard_pids = override_dboard_pids or []
         if override_dboard_pids:
-            self.log.warning("Overriding daughterboard PIDs! {}"
+            self.log.warning("Overriding daughterboard PIDs with: {}"
                              .format(override_dboard_pids))
         dboard_eeprom_addrs = self.dboard_eeprom_addr \
                               if isinstance(self.dboard_eeprom_addr, list) \
@@ -315,7 +315,7 @@ class PeriphManagerBase(object):
             else:
                 db_pid = dboard_eeprom_md.get('pid')
                 if db_pid is None:
-                    self.log.warning("No dboard PID found!")
+                    self.log.warning("No dboard PID found in dboard EEPROM!")
                 else:
                     self.log.debug("Found dboard PID in EEPROM: 0x{:04X}"
                                    .format(db_pid))
@@ -327,7 +327,7 @@ class PeriphManagerBase(object):
             if len(self.dboard_spimaster_addrs) > dboard_idx:
                 spi_nodes = sorted(get_spidev_nodes(
                     self.dboard_spimaster_addrs[dboard_idx]))
-                self.log.debug("Found spidev nodes: {0}".format(spi_nodes))
+                self.log.trace("Found spidev nodes: {0}".format(spi_nodes))
             else:
                 spi_nodes = []
                 self.log.warning("No SPI nodes for dboard %d.", dboard_idx)
@@ -363,7 +363,7 @@ class PeriphManagerBase(object):
         args -- A dictionary of args for initialization. Similar to device args
                 in UHD.
         """
-        self.log.info("Mboard init() called with device args `{}'.".format(
+        self.log.info("init() called with device args `{}'.".format(
             ",".join(['{}={}'.format(x, args[x]) for x in args])
         ))
         if not self._device_initialized:
@@ -407,7 +407,7 @@ class PeriphManagerBase(object):
         Tear down all members that need to be specially handled before
         deconstruction.
         """
-        self.log.debug("Teardown called for Peripheral Manager base.")
+        self.log.trace("Teardown called for Peripheral Manager base.")
 
     ###########################################################################
     # Misc device status controls and indicators
@@ -814,7 +814,7 @@ class PeriphManagerBase(object):
         Consider this a "post claim hook", not a function to actually claim
         this device (which happens outside of this class).
         """
-        self.log.debug("Device was claimed. No actions defined.")
+        self.log.trace("Device was claimed. No actions defined.")
 
     def unclaim(self):
         """
diff --git a/mpm/python/usrp_mpm/periph_manager/n3xx.py b/mpm/python/usrp_mpm/periph_manager/n3xx.py
index 455206d84..0a532772d 100644
--- a/mpm/python/usrp_mpm/periph_manager/n3xx.py
+++ b/mpm/python/usrp_mpm/periph_manager/n3xx.py
@@ -304,18 +304,18 @@ class MboardRegsControl(object):
         if time_source == 'internal':
             assert ref_clk_freq in (10e6, 25e6)
             if ref_clk_freq == 10e6:
-                self.log.trace("Setting time source to internal "
+                self.log.debug("Setting time source to internal "
                                "(10 MHz reference)...")
                 pps_sel_val = 0b1 << self.MB_CLOCK_CTRL_PPS_SEL_INT_10
             elif ref_clk_freq == 25e6:
-                self.log.trace("Setting time source to internal "
+                self.log.debug("Setting time source to internal "
                                "(25 MHz reference)...")
                 pps_sel_val = 0b1 << self.MB_CLOCK_CTRL_PPS_SEL_INT_25
         elif time_source == 'external':
-            self.log.trace("Setting time source to external...")
+            self.log.debug("Setting time source to external...")
             pps_sel_val = 0b1 << self.MB_CLOCK_CTRL_PPS_SEL_EXT
         elif time_source == 'gpsdo':
-            self.log.trace("Setting time source to gpsdo...")
+            self.log.debug("Setting time source to gpsdo...")
             pps_sel_val = 0b1 << self.MB_CLOCK_CTRL_PPS_SEL_GPSDO
         else:
             assert False
@@ -590,15 +590,13 @@ class n3xx(PeriphManagerBase):
         - GPS lock (update back-panel GPS LED)
         - REF lock (update back-panel REF LED)
         """
-        self.log.trace("Launching monitor thread...")
+        self.log.trace("Launching monitor loop...")
         cond = threading.Condition()
         cond.acquire()
         while not self._tear_down:
             gps_locked = bool(self._gpios.get("GPS-LOCKOK"))
-            self.log.trace("Setting GPS LED to {}".format(gps_locked))
             self._bp_leds.set(self._bp_leds.LED_GPS, int(gps_locked))
             ref_locked = self.get_ref_lock_sensor()['value'] == 'true'
-            self.log.trace("Setting REF LED to {}".format(ref_locked))
             self._bp_leds.set(self._bp_leds.LED_REF, int(ref_locked))
             # Now wait
             if cond.wait_for(
@@ -606,7 +604,7 @@ class n3xx(PeriphManagerBase):
                     N3XX_MONITOR_THREAD_INTERVAL):
                 break
         cond.release()
-        self.log.trace("Terminating monitor thread.")
+        self.log.trace("Terminating monitor loop.")
 
     def _init_peripherals(self, args):
         """
@@ -622,7 +620,7 @@ class n3xx(PeriphManagerBase):
         # Init peripherals
         self.log.trace("Initializing TCA6424 port expander controls...")
         self._gpios = TCA6424(int(self.mboard_info['rev']))
-        self.log.trace("Initializing back panel led controls...")
+        self.log.trace("Initializing back panel LED controls...")
         self._bp_leds = BackpanelGPIO()
         self.log.trace("Enabling power of MGT156MHZ clk")
         self._gpios.set("PWREN-CLK-MGT156MHz")
@@ -677,7 +675,7 @@ class n3xx(PeriphManagerBase):
         dispatchers accordingly.
         """
         if not self._device_initialized:
-            self.log.warning(
+            self.log.error(
                 "Cannot run init(), device was never fully initialized!")
             return False
         if "clock_source" in args:
@@ -714,7 +712,8 @@ class n3xx(PeriphManagerBase):
         if self._device_initialized:
             self._status_monitor_thread.join(3 * N3XX_MONITOR_THREAD_INTERVAL)
             if self._status_monitor_thread.is_alive():
-                self.log.error("Could not terminate monitor thread!")
+                self.log.error("Could not terminate monitor thread! "
+                               "This could result in resource leaks.")
         active_overlays = self.list_active_overlays()
         self.log.trace("N3xx has active device tree overlays: {}".format(
             active_overlays
@@ -744,7 +743,7 @@ class n3xx(PeriphManagerBase):
                 src_address = self._available_endpoints[0]
         sid = SID(src_address << 16 | dst_address)
         # Note: This SID may change its source address!
-        self.log.debug(
+        self.log.trace(
             "request_xport(dst=0x%04X, suggested_src_address=0x%04X, xport_type=%s): " \
             "operating on temporary SID: %s",
             dst_address, suggested_src_address, str(xport_type), str(sid))
@@ -816,7 +815,7 @@ class n3xx(PeriphManagerBase):
         """
         clock_source = args[0]
         assert clock_source in self.get_clock_sources()
-        self.log.trace("Setting clock source to `{}'".format(clock_source))
+        self.log.debug("Setting clock source to `{}'".format(clock_source))
         if clock_source == self.get_clock_source():
             self.log.trace("Nothing to do -- clock source already set.")
             return
@@ -835,7 +834,7 @@ class n3xx(PeriphManagerBase):
             self._gpios.set("CLK-MAINSEL-25MHz")
         self._clock_source = clock_source
         ref_clk_freq = self.get_ref_clock_freq()
-        self.log.info("Reference clock frequency is: {} MHz".format(
+        self.log.debug("Reference clock frequency is: {} MHz".format(
             ref_clk_freq/1e6
         ))
         for slot, dboard in enumerate(self.dboards):
@@ -1008,7 +1007,7 @@ class n3xx(PeriphManagerBase):
         """
         Get temperature sensor reading of the N3xx.
         """
-        self.log.trace("Reading fpga temperature.")
+        self.log.trace("Reading FPGA temperature.")
         return_val = '-1'
         try:
             raw_val = read_thermal_sensor_value('fpga-thermal-zone', 'temp')
@@ -1028,7 +1027,7 @@ class n3xx(PeriphManagerBase):
         """
         Get cooling device reading of N3xx. In this case the speed of fan 0.
         """
-        self.log.trace("Reading fpga cooling device.")
+        self.log.trace("Reading FPGA cooling device.")
         return_val = '-1'
         try:
             raw_val = read_thermal_sensor_value('ec-fan0', 'cur_state')
@@ -1226,12 +1225,10 @@ class n3xx(PeriphManagerBase):
             from usrp_mpm.fpga_bit_to_bin import fpga_bit_to_bin
             fpga_bit_to_bin(filepath, binfile_path, flip=True)
         elif file_extension == "bin":
-            self.log.trace("Copying bin file to {}"
-                           .format(binfile_path))
+            self.log.trace("Copying bin file to %s", binfile_path)
             shutil.copy(filepath, binfile_path)
         else:
-            self.log.error("Invalid FPGA bitfile: {}"
-                           .format(filepath))
+            self.log.error("Invalid FPGA bitfile: %s", filepath)
             raise RuntimeError("Invalid N3xx FPGA bitfile")
         # RPC server will reload the periph manager after this.
         return True
@@ -1251,12 +1248,12 @@ class n3xx(PeriphManagerBase):
         :param metadata: Dictionary of strings containing metadata
         """
         dtsfile_path = self.updateable_components['dts']['path'].format(
-                self.mboard_info['product'])
+            self.mboard_info['product'])
         self.log.trace("Updating DTS with image at %s to %s (metadata: %s)",
                        filepath, dtsfile_path, str(metadata))
         shutil.copy(filepath, dtsfile_path)
         dtbofile_path = self.updateable_components['dts']['output'].format(
-                self.mboard_info['product'])
+            self.mboard_info['product'])
         self.log.trace("Compiling to %s...", dtbofile_path)
         dtc_command = [
             'dtc',
@@ -1271,6 +1268,8 @@ class n3xx(PeriphManagerBase):
         try:
             out = subprocess.check_output(dtc_command)
             if out.strip() != "":
+                # Keep this as debug because dtc is an external tool and
+                # something could go wrong with it that's outside of our control
                 self.log.debug("`dtc' command output: \n%s", out)
         except OSError as ex:
             self.log.error("Could not execute `dtc' command. Binary probably "\
diff --git a/mpm/python/usrp_mpm/xports/xportmgr_udp.py b/mpm/python/usrp_mpm/xports/xportmgr_udp.py
index fe7a9a9d4..c7d36af29 100644
--- a/mpm/python/usrp_mpm/xports/xportmgr_udp.py
+++ b/mpm/python/usrp_mpm/xports/xportmgr_udp.py
@@ -62,7 +62,7 @@ class XportMgrUDP(object):
         if len(valid_ifaces):
             self.log.debug("Found CHDR interfaces: `{}'".format(valid_ifaces))
         else:
-            self.log.warning("No CHDR interfaces found!")
+            self.log.info("No CHDR interfaces found!")
         return {
             x: net.get_iface_info(x)
             for x in valid_ifaces
-- 
2.11.0

